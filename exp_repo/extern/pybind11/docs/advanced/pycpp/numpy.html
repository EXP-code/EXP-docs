<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>NumPy &mdash; EXP 0.172 documentation</title>
      <link rel="stylesheet" href="../../../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../../../../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../../../../../../_static/copybutton.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../../../../../_static/documentation_options.js?v=9c6809b7"></script>
        <script src="../../../../../../_static/doctools.js?v=888ff710"></script>
        <script src="../../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="../../../../../../_static/clipboard.min.js?v=a7894cd8"></script>
        <script src="../../../../../../_static/copybutton.js?v=5eb1bb1e"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../../index.html" class="icon icon-home">
            EXP
              <img src="../../../../../../_static/exp_logo_white.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                7.x
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">First steps</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../intro/overview.html">EXP at a glance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../intro/install.html">Installation guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../intro/tutorial.html">Tutorials</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">EXP concepts</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../topics/bfetheory.html">BFE theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../topics/codeintro.html">Code intro</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../topics/timesseries.html">BFE time series analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../topics/units.html">Units in EXP and pyEXP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../topics/multistep.html">N-Body optimization in EXP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../topics/centering.html">Centering</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../topics/yamlconfig.html">What is YAML?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../topics/yamlconfig.html#an-annotated-exp-yaml-configuration">An annotated EXP YAML configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../topics/howtosim.html">How to run your own N-body simulation in EXP</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Frequently Asked Questions (FAQ)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../faq.html">Are there pre-compiled versions of pyEXP and EXP?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../faq.html#i-only-want-pyexp-do-i-need-c-to-compile-exp">I only want pyEXP, do I need C++ to compile EXP?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../faq.html#why-would-i-use-exp-rather-than-pyexp">Why would I use EXP rather than pyEXP?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../faq.html#what-hardware-do-i-need-to-run-exp-and-pyexp">What hardware do I need to run EXP and pyEXP?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../faq.html#how-do-i-restart-exp-from-a-checkpoint">How do I restart EXP from a checkpoint?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../faq.html#my-hpc-cluster-does-not-have-the-required-dependencies-what-are-my-options">My HPC cluster does not have the required dependencies.  What are my options?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../faq.html#can-i-run-exp-or-pyexp-in-a-container">Can I run EXP or pyEXP in a container?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../faq.html#i-got-a-seg-fault-now-what-do-i-do">I got a “seg fault”, now what do I do?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../faq.html#how-can-i-do-a-calculation-with-phase-space-in-pyexp">How can I do a calculation with phase space in pyEXP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../faq.html#what-do-these-parameters-mean">What do these parameters mean?</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">How to solve specific problems</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../topics/visualizing-bases.html">How to visualize the BFE bases used to make your coefficients</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../topics/making-coefficients.html">How to  generate coefficients from phase-space snapshots</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../topics/saving-coefficients.html">How to save and reuse your newly generated coefficients</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../topics/visualizing-fields.html">How to convert your coefficients back to physical fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../topics/make-movies.html">Making movies of your BFE field quantities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../topics/using-mssa.html">How to use mSSA with your coefficient series in pyEXP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../topics/orbits.html">Generating orbits in your BFE potential fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../topics/replay.html">Replaying a simulation using EXP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../topics/exp-phase-space.html">The EXP phase-space format</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../topics/EXP-output.html">How the EXP N-body code selects what and when to write data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../topics/flatdisk.html">How to configure a razor-thin disk</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../topics/debug.html">Debugging EXP</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Extending EXP</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../topics/design.html">Software design goals and features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../topics/design.html#overall-organization-of-the-code">Overall organization of the code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../topics/design.html#parallel-usage">Parallel usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../topics/usermodules.html">User modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../topics/newforces.html">How to make a new EXP force</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">More about EXP</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../news.html">Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../contributing.html">Contributing to EXP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../doxygen.html">Index to C++ classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../pybind11.html">Index to pyEXP classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../../versioning.html">Versioning and API stability</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../../index.html">EXP</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">NumPy</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../../_sources/exp_repo/extern/pybind11/docs/advanced/pycpp/numpy.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="numpy">
<span id="id1"></span><h1>NumPy<a class="headerlink" href="#numpy" title="Link to this heading"></a></h1>
<section id="buffer-protocol">
<h2>Buffer protocol<a class="headerlink" href="#buffer-protocol" title="Link to this heading"></a></h2>
<p>Python supports an extremely general and convenient approach for exchanging
data between plugin libraries. Types can expose a buffer view <a class="footnote-reference brackets" href="#f2" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>, which
provides fast direct access to the raw internal data representation. Suppose we
want to bind the following simplistic Matrix class:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Matrix</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">Matrix</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">rows</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">cols</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">m_rows</span><span class="p">(</span><span class="n">rows</span><span class="p">),</span><span class="w"> </span><span class="n">m_cols</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">m_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">float</span><span class="p">[</span><span class="n">rows</span><span class="o">*</span><span class="n">cols</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">m_data</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">rows</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">m_rows</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">cols</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">m_cols</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">m_rows</span><span class="p">,</span><span class="w"> </span><span class="n">m_cols</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="n">m_data</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The following binding code exposes the <code class="docutils literal notranslate"><span class="pre">Matrix</span></code> contents as a buffer object,
making it possible to cast Matrices into NumPy arrays. It is even possible to
completely avoid copy operations with Python expressions like
<code class="docutils literal notranslate"><span class="pre">np.array(matrix_instance,</span> <span class="pre">copy</span> <span class="pre">=</span> <span class="pre">False)</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">Matrix</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Matrix&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">py</span><span class="o">::</span><span class="n">buffer_protocol</span><span class="p">())</span>
<span class="w">   </span><span class="p">.</span><span class="n">def_buffer</span><span class="p">([](</span><span class="n">Matrix</span><span class="w"> </span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">py</span><span class="o">::</span><span class="n">buffer_info</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">py</span><span class="o">::</span><span class="n">buffer_info</span><span class="p">(</span>
<span class="w">            </span><span class="n">m</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w">                               </span><span class="cm">/* Pointer to buffer */</span>
<span class="w">            </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span><span class="w">                          </span><span class="cm">/* Size of one scalar */</span>
<span class="w">            </span><span class="n">py</span><span class="o">::</span><span class="n">format_descriptor</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;::</span><span class="n">format</span><span class="p">(),</span><span class="w"> </span><span class="cm">/* Python struct-style format descriptor */</span>
<span class="w">            </span><span class="mi">2</span><span class="p">,</span><span class="w">                                      </span><span class="cm">/* Number of dimensions */</span>
<span class="w">            </span><span class="p">{</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">rows</span><span class="p">(),</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">cols</span><span class="p">()</span><span class="w"> </span><span class="p">},</span><span class="w">                 </span><span class="cm">/* Buffer dimensions */</span>
<span class="w">            </span><span class="p">{</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">cols</span><span class="p">(),</span><span class="w">             </span><span class="cm">/* Strides (in bytes) for each index */</span>
<span class="w">              </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
<span class="w">        </span><span class="p">);</span>
<span class="w">    </span><span class="p">});</span>
</pre></div>
</div>
<p>Supporting the buffer protocol in a new type involves specifying the special
<code class="docutils literal notranslate"><span class="pre">py::buffer_protocol()</span></code> tag in the <code class="docutils literal notranslate"><span class="pre">py::class_</span></code> constructor and calling the
<code class="docutils literal notranslate"><span class="pre">def_buffer()</span></code> method with a lambda function that creates a
<code class="docutils literal notranslate"><span class="pre">py::buffer_info</span></code> description record on demand describing a given matrix
instance. The contents of <code class="docutils literal notranslate"><span class="pre">py::buffer_info</span></code> mirror the Python buffer protocol
specification.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">buffer_info</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
<span class="w">    </span><span class="n">py</span><span class="o">::</span><span class="kt">ssize_t</span><span class="w"> </span><span class="n">itemsize</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">format</span><span class="p">;</span>
<span class="w">    </span><span class="n">py</span><span class="o">::</span><span class="kt">ssize_t</span><span class="w"> </span><span class="n">ndim</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">py</span><span class="o">::</span><span class="kt">ssize_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">shape</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">py</span><span class="o">::</span><span class="kt">ssize_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">strides</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>To create a C++ function that can take a Python buffer object as an argument,
simply use the type <code class="docutils literal notranslate"><span class="pre">py::buffer</span></code> as one of its arguments. Buffers can exist
in a great variety of configurations, hence some safety checks are usually
necessary in the function body. Below, you can see a basic example on how to
define a custom constructor for the Eigen double precision matrix
(<code class="docutils literal notranslate"><span class="pre">Eigen::MatrixXd</span></code>) type, which supports initialization from compatible
buffer objects (e.g. a NumPy matrix).</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Bind MatrixXd (or some other Eigen type) to Python */</span>
<span class="k">typedef</span><span class="w"> </span><span class="n">Eigen</span><span class="o">::</span><span class="n">MatrixXd</span><span class="w"> </span><span class="n">Matrix</span><span class="p">;</span>

<span class="k">typedef</span><span class="w"> </span><span class="n">Matrix</span><span class="o">::</span><span class="n">Scalar</span><span class="w"> </span><span class="n">Scalar</span><span class="p">;</span>
<span class="k">constexpr</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">rowMajor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Matrix</span><span class="o">::</span><span class="n">Flags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">Eigen</span><span class="o">::</span><span class="n">RowMajorBit</span><span class="p">;</span>

<span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">Matrix</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Matrix&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">py</span><span class="o">::</span><span class="n">buffer_protocol</span><span class="p">())</span>
<span class="w">    </span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">init</span><span class="p">([](</span><span class="n">py</span><span class="o">::</span><span class="n">buffer</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">typedef</span><span class="w"> </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Stride</span><span class="o">&lt;</span><span class="n">Eigen</span><span class="o">::</span><span class="n">Dynamic</span><span class="p">,</span><span class="w"> </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Dynamic</span><span class="o">&gt;</span><span class="w"> </span><span class="n">Strides</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/* Request a buffer descriptor from Python */</span>
<span class="w">        </span><span class="n">py</span><span class="o">::</span><span class="n">buffer_info</span><span class="w"> </span><span class="n">info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">request</span><span class="p">();</span>

<span class="w">        </span><span class="cm">/* Some basic validation checks ... */</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">format</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">py</span><span class="o">::</span><span class="n">format_descriptor</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;::</span><span class="n">format</span><span class="p">())</span>
<span class="w">            </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;Incompatible format: expected a double array!&quot;</span><span class="p">);</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">ndim</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="w">            </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;Incompatible buffer dimension!&quot;</span><span class="p">);</span>

<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">strides</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Strides</span><span class="p">(</span>
<span class="w">            </span><span class="n">info</span><span class="p">.</span><span class="n">strides</span><span class="p">[</span><span class="n">rowMajor</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="kt">ssize_t</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Scalar</span><span class="p">),</span>
<span class="w">            </span><span class="n">info</span><span class="p">.</span><span class="n">strides</span><span class="p">[</span><span class="n">rowMajor</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="kt">ssize_t</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Scalar</span><span class="p">));</span>

<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">Matrix</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">Strides</span><span class="o">&gt;</span><span class="p">(</span>
<span class="w">            </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="w"> </span><span class="o">*&gt;</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">ptr</span><span class="p">),</span><span class="w"> </span><span class="n">info</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">info</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">strides</span><span class="p">);</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">Matrix</span><span class="p">(</span><span class="n">map</span><span class="p">);</span>
<span class="w">    </span><span class="p">}));</span>
</pre></div>
</div>
<p>For reference, the <code class="docutils literal notranslate"><span class="pre">def_buffer()</span></code> call for this Eigen data type should look
as follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">.</span><span class="n">def_buffer</span><span class="p">([](</span><span class="n">Matrix</span><span class="w"> </span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">py</span><span class="o">::</span><span class="n">buffer_info</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">py</span><span class="o">::</span><span class="n">buffer_info</span><span class="p">(</span>
<span class="w">        </span><span class="n">m</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w">                                </span><span class="cm">/* Pointer to buffer */</span>
<span class="w">        </span><span class="k">sizeof</span><span class="p">(</span><span class="n">Scalar</span><span class="p">),</span><span class="w">                          </span><span class="cm">/* Size of one scalar */</span>
<span class="w">        </span><span class="n">py</span><span class="o">::</span><span class="n">format_descriptor</span><span class="o">&lt;</span><span class="n">Scalar</span><span class="o">&gt;::</span><span class="n">format</span><span class="p">(),</span><span class="w"> </span><span class="cm">/* Python struct-style format descriptor */</span>
<span class="w">        </span><span class="mi">2</span><span class="p">,</span><span class="w">                                       </span><span class="cm">/* Number of dimensions */</span>
<span class="w">        </span><span class="p">{</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">rows</span><span class="p">(),</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">cols</span><span class="p">()</span><span class="w"> </span><span class="p">},</span><span class="w">                  </span><span class="cm">/* Buffer dimensions */</span>
<span class="w">        </span><span class="p">{</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">Scalar</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">rowMajor</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">cols</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span>
<span class="w">          </span><span class="k">sizeof</span><span class="p">(</span><span class="n">Scalar</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">rowMajor</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">rows</span><span class="p">())</span><span class="w"> </span><span class="p">}</span>
<span class="w">                                                 </span><span class="cm">/* Strides (in bytes) for each index */</span>
<span class="w">    </span><span class="p">);</span>
<span class="w"> </span><span class="p">})</span>
</pre></div>
</div>
<p>For a much easier approach of binding Eigen types (although with some
limitations), refer to the section on <span class="xref std std-doc">/advanced/cast/eigen</span>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>The file <code class="file docutils literal notranslate"><span class="pre">tests/test_buffers.cpp</span></code> contains a complete example
that demonstrates using the buffer protocol with pybind11 in more detail.</p>
</div>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="f2" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">1</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://docs.python.org/3/c-api/buffer.html">http://docs.python.org/3/c-api/buffer.html</a></p>
</aside>
</aside>
</section>
<section id="arrays">
<h2>Arrays<a class="headerlink" href="#arrays" title="Link to this heading"></a></h2>
<p>By exchanging <code class="docutils literal notranslate"><span class="pre">py::buffer</span></code> with <code class="docutils literal notranslate"><span class="pre">py::array</span></code> in the above snippet, we can
restrict the function so that it only accepts NumPy arrays (rather than any
type of Python object satisfying the buffer protocol).</p>
<p>In many situations, we want to define a function which only accepts a NumPy
array of a certain data type. This is possible via the <code class="docutils literal notranslate"><span class="pre">py::array_t&lt;T&gt;</span></code>
template. For instance, the following function requires the argument to be a
NumPy array containing double precision values.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">array_t</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">array</span><span class="p">);</span>
</pre></div>
</div>
<p>When it is invoked with a different type (e.g. an integer or a list of
integers), the binding code will attempt to cast the input into a NumPy array
of the requested type. This feature requires the <code class="file docutils literal notranslate"><span class="pre">pybind11/numpy.h</span></code>
header to be included. Note that <code class="file docutils literal notranslate"><span class="pre">pybind11/numpy.h</span></code> does not depend on
the NumPy headers, and thus can be used without declaring a build-time
dependency on NumPy; NumPy&gt;=1.7.0 is a runtime dependency.</p>
<p>Data in NumPy arrays is not guaranteed to packed in a dense manner;
furthermore, entries can be separated by arbitrary column and row strides.
Sometimes, it can be useful to require a function to only accept dense arrays
using either the C (row-major) or Fortran (column-major) ordering. This can be
accomplished via a second template argument with values <code class="docutils literal notranslate"><span class="pre">py::array::c_style</span></code>
or <code class="docutils literal notranslate"><span class="pre">py::array::f_style</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">array_t</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="n">py</span><span class="o">::</span><span class="n">array</span><span class="o">::</span><span class="n">c_style</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">py</span><span class="o">::</span><span class="n">array</span><span class="o">::</span><span class="n">forcecast</span><span class="o">&gt;</span><span class="w"> </span><span class="n">array</span><span class="p">);</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">py::array::forcecast</span></code> argument is the default value of the second
template parameter, and it ensures that non-conforming arguments are converted
into an array satisfying the specified requirements instead of trying the next
function overload.</p>
<p>There are several methods on arrays; the methods listed below under references
work, as well as the following functions based on the NumPy API:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">.dtype()</span></code> returns the type of the contained values.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">.strides()</span></code> returns a pointer to the strides of the array (optionally pass
an integer axis to get a number).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">.flags()</span></code> returns the flag settings. <code class="docutils literal notranslate"><span class="pre">.writable()</span></code> and <code class="docutils literal notranslate"><span class="pre">.owndata()</span></code>
are directly available.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">.offset_at()</span></code> returns the offset (optionally pass indices).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">.squeeze()</span></code> returns a view with length-1 axes removed.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">.view(dtype)</span></code> returns a view of the array with a different dtype.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">.reshape({i,</span> <span class="pre">j,</span> <span class="pre">...})</span></code> returns a view of the array with a different shape.
<code class="docutils literal notranslate"><span class="pre">.resize({...})</span></code> is also available.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">.index_at(i,</span> <span class="pre">j,</span> <span class="pre">...)</span></code> gets the count from the beginning to a given index.</p></li>
</ul>
<p>There are also several methods for getting references (described below).</p>
</section>
<section id="structured-types">
<h2>Structured types<a class="headerlink" href="#structured-types" title="Link to this heading"></a></h2>
<p>In order for <code class="docutils literal notranslate"><span class="pre">py::array_t</span></code> to work with structured (record) types, we first
need to register the memory layout of the type. This can be done via
<code class="docutils literal notranslate"><span class="pre">PYBIND11_NUMPY_DTYPE</span></code> macro, called in the plugin definition code, which
expects the type followed by field names:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">A</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">B</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">z</span><span class="p">;</span>
<span class="w">    </span><span class="n">A</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// ...</span>
<span class="n">PYBIND11_MODULE</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// ...</span>

<span class="w">    </span><span class="n">PYBIND11_NUMPY_DTYPE</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">);</span>
<span class="w">    </span><span class="n">PYBIND11_NUMPY_DTYPE</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/* now both A and B can be used as template arguments to py::array_t */</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The structure should consist of fundamental arithmetic types, <code class="docutils literal notranslate"><span class="pre">std::complex</span></code>,
previously registered substructures, and arrays of any of the above. Both C++
arrays and <code class="docutils literal notranslate"><span class="pre">std::array</span></code> are supported. While there is a static assertion to
prevent many types of unsupported structures, it is still the user’s
responsibility to use only “plain” structures that can be safely manipulated as
raw memory without violating invariants.</p>
</section>
<section id="vectorizing-functions">
<h2>Vectorizing functions<a class="headerlink" href="#vectorizing-functions" title="Link to this heading"></a></h2>
<p>Suppose we want to bind a function with the following signature to Python so
that it can process arbitrary NumPy array arguments (vectors, matrices, general
N-D arrays) in addition to its normal arguments:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">double</span><span class="w"> </span><span class="nf">my_func</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">z</span><span class="p">);</span>
</pre></div>
</div>
<p>After including the <code class="docutils literal notranslate"><span class="pre">pybind11/numpy.h</span></code> header, this is extremely simple:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">m</span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;vectorized_func&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">py</span><span class="o">::</span><span class="n">vectorize</span><span class="p">(</span><span class="n">my_func</span><span class="p">));</span>
</pre></div>
</div>
<p>Invoking the function like below causes 4 calls to be made to <code class="docutils literal notranslate"><span class="pre">my_func</span></code> with
each of the array elements. The significant advantage of this compared to
solutions like <code class="docutils literal notranslate"><span class="pre">numpy.vectorize()</span></code> is that the loop over the elements runs
entirely on the C++ side and can be crunched down into a tight, optimized loop
by the compiler. The result is returned as a NumPy array of type
<code class="docutils literal notranslate"><span class="pre">numpy.dtype.float64</span></code>.</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">vectorized_func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
</pre></div>
</div>
<p>The scalar argument <code class="docutils literal notranslate"><span class="pre">z</span></code> is transparently replicated 4 times.  The input
arrays <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> are automatically converted into the right types (they
are of type  <code class="docutils literal notranslate"><span class="pre">numpy.dtype.int64</span></code> but need to be <code class="docutils literal notranslate"><span class="pre">numpy.dtype.int32</span></code> and
<code class="docutils literal notranslate"><span class="pre">numpy.dtype.float32</span></code>, respectively).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Only arithmetic, complex, and POD types passed by value or by <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">&amp;</span></code>
reference are vectorized; all other arguments are passed through as-is.
Functions taking rvalue reference arguments cannot be vectorized.</p>
</div>
<p>In cases where the computation is too complicated to be reduced to
<code class="docutils literal notranslate"><span class="pre">vectorize</span></code>, it will be necessary to create and access the buffer contents
manually. The following snippet contains a complete example that shows how this
works (the code is somewhat contrived, since it could have been done more
simply using <code class="docutils literal notranslate"><span class="pre">vectorize</span></code>).</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pybind11/pybind11.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pybind11/numpy.h&gt;</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">py</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">pybind11</span><span class="p">;</span>

<span class="n">py</span><span class="o">::</span><span class="n">array_t</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">add_arrays</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">array_t</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">input1</span><span class="p">,</span><span class="w"> </span><span class="n">py</span><span class="o">::</span><span class="n">array_t</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">input2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">py</span><span class="o">::</span><span class="n">buffer_info</span><span class="w"> </span><span class="n">buf1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">input1</span><span class="p">.</span><span class="n">request</span><span class="p">(),</span><span class="w"> </span><span class="n">buf2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">input2</span><span class="p">.</span><span class="n">request</span><span class="p">();</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">buf1</span><span class="p">.</span><span class="n">ndim</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">buf2</span><span class="p">.</span><span class="n">ndim</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">        </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;Number of dimensions must be one&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">buf1</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">buf2</span><span class="p">.</span><span class="n">size</span><span class="p">)</span>
<span class="w">        </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;Input shapes must match&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* No pointer is passed, so NumPy will allocate the buffer */</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">py</span><span class="o">::</span><span class="n">array_t</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">buf1</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>

<span class="w">    </span><span class="n">py</span><span class="o">::</span><span class="n">buffer_info</span><span class="w"> </span><span class="n">buf3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">result</span><span class="p">.</span><span class="n">request</span><span class="p">();</span>

<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">ptr1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="w"> </span><span class="o">*&gt;</span><span class="p">(</span><span class="n">buf1</span><span class="p">.</span><span class="n">ptr</span><span class="p">);</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">ptr2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="w"> </span><span class="o">*&gt;</span><span class="p">(</span><span class="n">buf2</span><span class="p">.</span><span class="n">ptr</span><span class="p">);</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">ptr3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="w"> </span><span class="o">*&gt;</span><span class="p">(</span><span class="n">buf3</span><span class="p">.</span><span class="n">ptr</span><span class="p">);</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">buf1</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"> </span><span class="n">idx</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="n">ptr3</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ptr1</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">ptr2</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">PYBIND11_MODULE</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;add_arrays&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">add_arrays</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Add two NumPy arrays&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>The file <code class="file docutils literal notranslate"><span class="pre">tests/test_numpy_vectorize.cpp</span></code> contains a complete
example that demonstrates using <code class="xref py py-func docutils literal notranslate"><span class="pre">vectorize()</span></code> in more detail.</p>
</div>
</section>
<section id="direct-access">
<h2>Direct access<a class="headerlink" href="#direct-access" title="Link to this heading"></a></h2>
<p>For performance reasons, particularly when dealing with very large arrays, it
is often desirable to directly access array elements without internal checking
of dimensions and bounds on every access when indices are known to be already
valid.  To avoid such checks, the <code class="docutils literal notranslate"><span class="pre">array</span></code> class and <code class="docutils literal notranslate"><span class="pre">array_t&lt;T&gt;</span></code> template
class offer an unchecked proxy object that can be used for this unchecked
access through the <code class="docutils literal notranslate"><span class="pre">unchecked&lt;N&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">mutable_unchecked&lt;N&gt;</span></code> methods,
where <code class="docutils literal notranslate"><span class="pre">N</span></code> gives the required dimensionality of the array:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">m</span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;sum_3d&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">[](</span><span class="n">py</span><span class="o">::</span><span class="n">array_t</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">unchecked</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">();</span><span class="w"> </span><span class="c1">// x must have ndim = 3; can be non-writeable</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="kt">ssize_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">r</span><span class="p">.</span><span class="n">shape</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="kt">ssize_t</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">r</span><span class="p">.</span><span class="n">shape</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="kt">ssize_t</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">r</span><span class="p">.</span><span class="n">shape</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span><span class="w"> </span><span class="n">k</span><span class="o">++</span><span class="p">)</span>
<span class="w">                </span><span class="n">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">r</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">sum</span><span class="p">;</span>
<span class="p">});</span>
<span class="n">m</span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;increment_3d&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">[](</span><span class="n">py</span><span class="o">::</span><span class="n">array_t</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">mutable_unchecked</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">();</span><span class="w"> </span><span class="c1">// Will throw if ndim != 3 or flags.writeable is false</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="kt">ssize_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">r</span><span class="p">.</span><span class="n">shape</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="kt">ssize_t</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">r</span><span class="p">.</span><span class="n">shape</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="kt">ssize_t</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">r</span><span class="p">.</span><span class="n">shape</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span><span class="w"> </span><span class="n">k</span><span class="o">++</span><span class="p">)</span>
<span class="w">                </span><span class="n">r</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span>
<span class="p">},</span><span class="w"> </span><span class="n">py</span><span class="o">::</span><span class="n">arg</span><span class="p">().</span><span class="n">noconvert</span><span class="p">());</span>
</pre></div>
</div>
<p>To obtain the proxy from an <code class="docutils literal notranslate"><span class="pre">array</span></code> object, you must specify both the data
type and number of dimensions as template arguments, such as <code class="docutils literal notranslate"><span class="pre">auto</span> <span class="pre">r</span> <span class="pre">=</span>
<span class="pre">myarray.mutable_unchecked&lt;float,</span> <span class="pre">2&gt;()</span></code>.</p>
<p>If the number of dimensions is not known at compile time, you can omit the
dimensions template parameter (i.e. calling <code class="docutils literal notranslate"><span class="pre">arr_t.unchecked()</span></code> or
<code class="docutils literal notranslate"><span class="pre">arr.unchecked&lt;T&gt;()</span></code>.  This will give you a proxy object that works in the
same way, but results in less optimizable code and thus a small efficiency
loss in tight loops.</p>
<p>Note that the returned proxy object directly references the array’s data, and
only reads its shape, strides, and writeable flag when constructed.  You must
take care to ensure that the referenced array is not destroyed or reshaped for
the duration of the returned object, typically by limiting the scope of the
returned instance.</p>
<p>The returned proxy object supports some of the same methods as <code class="docutils literal notranslate"><span class="pre">py::array</span></code> so
that it can be used as a drop-in replacement for some existing, index-checked
uses of <code class="docutils literal notranslate"><span class="pre">py::array</span></code>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">.ndim()</span></code> returns the number of dimensions</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">.data(1,</span> <span class="pre">2,</span> <span class="pre">...)</span></code> and <code class="docutils literal notranslate"><span class="pre">r.mutable_data(1,</span> <span class="pre">2,</span> <span class="pre">...)`</span></code> returns a pointer to
the <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">T</span></code> or <code class="docutils literal notranslate"><span class="pre">T</span></code> data, respectively, at the given indices.  The
latter is only available to proxies obtained via <code class="docutils literal notranslate"><span class="pre">a.mutable_unchecked()</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">.itemsize()</span></code> returns the size of an item in bytes, i.e. <code class="docutils literal notranslate"><span class="pre">sizeof(T)</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">.shape(n)</span></code> returns the size of dimension <code class="docutils literal notranslate"><span class="pre">n</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">.size()</span></code> returns the total number of elements (i.e. the product of the shapes).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">.nbytes()</span></code> returns the number of bytes used by the referenced elements
(i.e. <code class="docutils literal notranslate"><span class="pre">itemsize()</span></code> times <code class="docutils literal notranslate"><span class="pre">size()</span></code>).</p></li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>The file <code class="file docutils literal notranslate"><span class="pre">tests/test_numpy_array.cpp</span></code> contains additional examples
demonstrating the use of this feature.</p>
</div>
</section>
<section id="ellipsis">
<h2>Ellipsis<a class="headerlink" href="#ellipsis" title="Link to this heading"></a></h2>
<p>Python provides a convenient <code class="docutils literal notranslate"><span class="pre">...</span></code> ellipsis notation that is often used to
slice multidimensional arrays. For instance, the following snippet extracts the
middle dimensions of a tensor with the first and last index set to zero.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># a NumPy array</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>The function <code class="docutils literal notranslate"><span class="pre">py::ellipsis()</span></code> function can be used to perform the same
operation on the C++ side:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">py</span><span class="o">::</span><span class="n">array</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="cm">/* A NumPy array */</span><span class="p">;</span>
<span class="n">py</span><span class="o">::</span><span class="n">array</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">py</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">py</span><span class="o">::</span><span class="n">ellipsis</span><span class="p">(),</span><span class="w"> </span><span class="mi">0</span><span class="p">)];</span>
</pre></div>
</div>
</section>
<section id="memory-view">
<h2>Memory view<a class="headerlink" href="#memory-view" title="Link to this heading"></a></h2>
<p>For a case when we simply want to provide a direct accessor to C/C++ buffer
without a concrete class object, we can return a <code class="docutils literal notranslate"><span class="pre">memoryview</span></code> object. Suppose
we wish to expose a <code class="docutils literal notranslate"><span class="pre">memoryview</span></code> for 2x4 uint8_t array, we can do the
following:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">buffer</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span>
<span class="w">    </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span>
<span class="p">};</span>
<span class="n">m</span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;get_memoryview2d&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">[]()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">py</span><span class="o">::</span><span class="n">memoryview</span><span class="o">::</span><span class="n">from_buffer</span><span class="p">(</span>
<span class="w">        </span><span class="n">buffer</span><span class="p">,</span><span class="w">                                    </span><span class="c1">// buffer pointer</span>
<span class="w">        </span><span class="p">{</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="p">},</span><span class="w">                                  </span><span class="c1">// shape (rows, cols)</span>
<span class="w">        </span><span class="p">{</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w">   </span><span class="c1">// strides in bytes</span>
<span class="w">    </span><span class="p">);</span>
<span class="p">});</span>
</pre></div>
</div>
<p>This approach is meant for providing a <code class="docutils literal notranslate"><span class="pre">memoryview</span></code> for a C/C++ buffer not
managed by Python. The user is responsible for managing the lifetime of the
buffer. Using a <code class="docutils literal notranslate"><span class="pre">memoryview</span></code> created in this way after deleting the buffer in
C++ side results in undefined behavior.</p>
<p>We can also use <code class="docutils literal notranslate"><span class="pre">memoryview::from_memory</span></code> for a simple 1D contiguous buffer:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">m</span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;get_memoryview1d&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">[]()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">py</span><span class="o">::</span><span class="n">memoryview</span><span class="o">::</span><span class="n">from_memory</span><span class="p">(</span>
<span class="w">        </span><span class="n">buffer</span><span class="p">,</span><span class="w">               </span><span class="c1">// buffer pointer</span>
<span class="w">        </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">8</span><span class="w">   </span><span class="c1">// buffer size</span>
<span class="w">    </span><span class="p">);</span>
<span class="p">});</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 2.6: </span><code class="docutils literal notranslate"><span class="pre">memoryview::from_memory</span></code> added.</p>
</div>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023-2025, EXP-code collaboration.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>