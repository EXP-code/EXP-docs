<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Exceptions &mdash; EXP 0.172 documentation</title>
      <link rel="stylesheet" href="../../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../../../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../../../../../_static/copybutton.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../../../../_static/documentation_options.js?v=9c6809b7"></script>
        <script src="../../../../../_static/doctools.js?v=888ff710"></script>
        <script src="../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="../../../../../_static/clipboard.min.js?v=a7894cd8"></script>
        <script src="../../../../../_static/copybutton.js?v=5eb1bb1e"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../index.html" class="icon icon-home">
            EXP
              <img src="../../../../../_static/exp_logo_white.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                7.x
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">First steps</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../intro/overview.html">EXP at a glance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../intro/install.html">Installation guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../intro/tutorial.html">Tutorials</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">EXP concepts</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../topics/bfetheory.html">BFE theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../topics/codeintro.html">Code intro</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../topics/timesseries.html">BFE time series analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../topics/multistep.html">N-Body optimization in EXP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../topics/centering.html">Centering</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../topics/yamlconfig.html">What is YAML?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../topics/yamlconfig.html#an-annotated-exp-yaml-configuration">An annotated EXP YAML configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../topics/howtosim.html">How to run your own N-body simulation in EXP</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Frequently Asked Questions (FAQ)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../faq.html">Are there pre-compiled versions of pyEXP and EXP?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../faq.html#i-only-want-pyexp-do-i-need-c-to-compile-exp">I only want pyEXP, do I need C++ to compile EXP?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../faq.html#why-would-i-use-exp-rather-than-pyexp">Why would I use EXP rather than pyEXP?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../faq.html#what-hardware-do-i-need-to-run-exp-and-pyexp">What hardware do I need to run EXP and pyEXP?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../faq.html#how-do-i-restart-exp-from-a-checkpoint">How do I restart EXP from a checkpoint?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../faq.html#my-hpc-cluster-does-not-have-the-required-dependencies-what-are-my-options">My HPC cluster does not have the required dependencies.  What are my options?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../faq.html#can-i-run-exp-or-pyexp-in-a-container">Can I run EXP or pyEXP in a container?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../faq.html#i-got-a-seg-fault-now-what-do-i-do">I got a “seg fault”, now what do I do?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../faq.html#how-can-i-do-a-calculation-with-phase-space-in-pyexp">How can I do a calculation with phase space in pyEXP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../faq.html#what-do-these-parameters-mean">What do these parameters mean?</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">How to solve specific problems</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../topics/visualizing-bases.html">How to visualize the BFE bases used to make your coefficients</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../topics/making-coefficients.html">How to  generate coefficients from phase-space snapshots</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../topics/saving-coefficients.html">How to save and reuse your newly generated coefficients</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../topics/visualizing-fields.html">How to convert your coefficients back to physical fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../topics/make-movies.html">Making movies of your BFE field quantities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../topics/using-mssa.html">How to use mSSA with your coefficient series in pyEXP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../topics/orbits.html">Generating orbits in your BFE potential fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../topics/replay.html">Replaying a simulation using EXP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../topics/exp-phase-space.html">The EXP phase-space format</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../topics/EXP-output.html">How the EXP N-body code selects what and when to write data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../topics/flatdisk.html">How to configure a razor-thin disk</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../topics/debug.html">Debugging EXP</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Extending EXP</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../topics/design.html">Software design goals and features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../topics/design.html#overall-organization-of-the-code">Overall organization of the code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../topics/design.html#parallel-usage">Parallel usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../topics/usermodules.html">User modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../topics/newforces.html">How to make a new EXP force</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">More about EXP</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../news.html">Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../contributing.html">Contributing to EXP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../doxygen.html">Index to C++ classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pybind11.html">Index to pyEXP classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../versioning.html">Versioning and API stability</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../index.html">EXP</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Exceptions</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../_sources/exp_repo/extern/pybind11/docs/advanced/exceptions.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="exceptions">
<h1>Exceptions<a class="headerlink" href="#exceptions" title="Link to this heading"></a></h1>
<section id="built-in-c-to-python-exception-translation">
<h2>Built-in C++ to Python exception translation<a class="headerlink" href="#built-in-c-to-python-exception-translation" title="Link to this heading"></a></h2>
<p>When Python calls C++ code through pybind11, pybind11 provides a C++ exception handler
that will trap C++ exceptions, translate them to the corresponding Python exception,
and raise them so that Python code can handle them.</p>
<p>pybind11 defines translations for <code class="docutils literal notranslate"><span class="pre">std::exception</span></code> and its standard
subclasses, and several special exception classes that translate to specific
Python exceptions. Note that these are not actually Python exceptions, so they
cannot be examined using the Python C API. Instead, they are pure C++ objects
that pybind11 will translate the corresponding Python exception when they arrive
at its exception handler.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Exception thrown by C++</p></th>
<th class="head"><p>Translated to Python exception type</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref py py-class docutils literal notranslate"><span class="pre">std::exception</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">RuntimeError</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-class docutils literal notranslate"><span class="pre">std::bad_alloc</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">MemoryError</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-class docutils literal notranslate"><span class="pre">std::domain_error</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ValueError</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-class docutils literal notranslate"><span class="pre">std::invalid_argument</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ValueError</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-class docutils literal notranslate"><span class="pre">std::length_error</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ValueError</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-class docutils literal notranslate"><span class="pre">std::out_of_range</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">IndexError</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-class docutils literal notranslate"><span class="pre">std::range_error</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ValueError</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-class docutils literal notranslate"><span class="pre">std::overflow_error</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">OverflowError</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11::stop_iteration</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">StopIteration</span></code> (used to implement
custom iterators)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11::index_error</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">IndexError</span></code> (used to indicate out
of bounds access in <code class="docutils literal notranslate"><span class="pre">__getitem__</span></code>,
<code class="docutils literal notranslate"><span class="pre">__setitem__</span></code>, etc.)</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11::key_error</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">KeyError</span></code> (used to indicate out
of bounds access in <code class="docutils literal notranslate"><span class="pre">__getitem__</span></code>,
<code class="docutils literal notranslate"><span class="pre">__setitem__</span></code> in dict-like
objects, etc.)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11::value_error</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ValueError</span></code> (used to indicate
wrong value passed in
<code class="docutils literal notranslate"><span class="pre">container.remove(...)</span></code>)</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11::type_error</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">TypeError</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11::buffer_error</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">BufferError</span></code></p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11::import_error</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ImportError</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11::attribute_error</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">AttributeError</span></code></p></td>
</tr>
<tr class="row-even"><td><p>Any other exception</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">RuntimeError</span></code></p></td>
</tr>
</tbody>
</table>
<p>Exception translation is not bidirectional. That is, <em>catching</em> the C++
exceptions defined above will not trap exceptions that originate from
Python. For that, catch <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11::error_already_set</span></code>. See <a class="reference internal" href="#handling-python-exceptions-cpp"><span class="std std-ref">below</span></a> for further details.</p>
<p>There is also a special exception <code class="xref py py-class docutils literal notranslate"><span class="pre">cast_error</span></code> that is thrown by
<code class="xref py py-func docutils literal notranslate"><span class="pre">handle::call()</span></code> when the input arguments cannot be converted to Python
objects.</p>
</section>
<section id="registering-custom-translators">
<h2>Registering custom translators<a class="headerlink" href="#registering-custom-translators" title="Link to this heading"></a></h2>
<p>If the default exception conversion policy described above is insufficient,
pybind11 also provides support for registering custom exception translators.
Similar to pybind11 classes, exception translators can be local to the module
they are defined in or global to the entire python session.  To register a simple
exception conversion that translates a C++ exception into a new Python exception
using the C++ exception’s <code class="docutils literal notranslate"><span class="pre">what()</span></code> method, a helper function is available:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">py</span><span class="o">::</span><span class="n">register_exception</span><span class="o">&lt;</span><span class="n">CppExp</span><span class="o">&gt;</span><span class="p">(</span><span class="k">module</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;PyExp&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>This call creates a Python exception class with the name <code class="docutils literal notranslate"><span class="pre">PyExp</span></code> in the given
module and automatically converts any encountered exceptions of type <code class="docutils literal notranslate"><span class="pre">CppExp</span></code>
into Python exceptions of type <code class="docutils literal notranslate"><span class="pre">PyExp</span></code>.</p>
<p>A matching function is available for registering a local exception translator:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">py</span><span class="o">::</span><span class="n">register_local_exception</span><span class="o">&lt;</span><span class="n">CppExp</span><span class="o">&gt;</span><span class="p">(</span><span class="k">module</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;PyExp&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>It is possible to specify base class for the exception using the third
parameter, a <code class="docutils literal notranslate"><span class="pre">handle</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">py</span><span class="o">::</span><span class="n">register_exception</span><span class="o">&lt;</span><span class="n">CppExp</span><span class="o">&gt;</span><span class="p">(</span><span class="k">module</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;PyExp&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">PyExc_RuntimeError</span><span class="p">);</span>
<span class="n">py</span><span class="o">::</span><span class="n">register_local_exception</span><span class="o">&lt;</span><span class="n">CppExp</span><span class="o">&gt;</span><span class="p">(</span><span class="k">module</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;PyExp&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">PyExc_RuntimeError</span><span class="p">);</span>
</pre></div>
</div>
<p>Then <code class="docutils literal notranslate"><span class="pre">PyExp</span></code> can be caught both as <code class="docutils literal notranslate"><span class="pre">PyExp</span></code> and <code class="docutils literal notranslate"><span class="pre">RuntimeError</span></code>.</p>
<p>The class objects of the built-in Python exceptions are listed in the Python
documentation on <a class="reference external" href="https://docs.python.org/3/c-api/exceptions.html#standard-exceptions">Standard Exceptions</a>.
The default base class is <code class="docutils literal notranslate"><span class="pre">PyExc_Exception</span></code>.</p>
<p>When more advanced exception translation is needed, the functions
<code class="docutils literal notranslate"><span class="pre">py::register_exception_translator(translator)</span></code> and
<code class="docutils literal notranslate"><span class="pre">py::register_local_exception_translator(translator)</span></code> can be used to register
functions that can translate arbitrary exception types (and which may include
additional logic to do so).  The functions takes a stateless callable (e.g. a
function pointer or a lambda function without captured variables) with the call
signature <code class="docutils literal notranslate"><span class="pre">void(std::exception_ptr)</span></code>.</p>
<p>When a C++ exception is thrown, the registered exception translators are tried
in reverse order of registration (i.e. the last registered translator gets the
first shot at handling the exception). All local translators will be tried
before a global translator is tried.</p>
<p>Inside the translator, <code class="docutils literal notranslate"><span class="pre">std::rethrow_exception</span></code> should be used within
a try block to re-throw the exception.  One or more catch clauses to catch
the appropriate exceptions should then be used with each clause using
<code class="docutils literal notranslate"><span class="pre">py::set_error()</span></code> (see below).</p>
<p>To declare a custom Python exception type, declare a <code class="docutils literal notranslate"><span class="pre">py::exception</span></code> variable
and use this in the associated exception translator (note: it is often useful
to make this a static declaration when using it inside a lambda expression
without requiring capturing).</p>
<p>The following example demonstrates this for a hypothetical exception classes
<code class="docutils literal notranslate"><span class="pre">MyCustomException</span></code> and <code class="docutils literal notranslate"><span class="pre">OtherException</span></code>: the first is translated to a
custom python exception <code class="docutils literal notranslate"><span class="pre">MyCustomError</span></code>, while the second is translated to a
standard python RuntimeError:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">PYBIND11_CONSTINIT</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">py</span><span class="o">::</span><span class="n">gil_safe_call_once_and_store</span><span class="o">&lt;</span><span class="n">py</span><span class="o">::</span><span class="n">object</span><span class="o">&gt;</span><span class="w"> </span><span class="n">exc_storage</span><span class="p">;</span>
<span class="n">exc_storage</span><span class="p">.</span><span class="n">call_once_and_store_result</span><span class="p">(</span>
<span class="w">    </span><span class="p">[</span><span class="o">&amp;</span><span class="p">]()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">py</span><span class="o">::</span><span class="n">exception</span><span class="o">&lt;</span><span class="n">MyCustomException</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;MyCustomError&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">});</span>
<span class="n">py</span><span class="o">::</span><span class="n">register_exception_translator</span><span class="p">([](</span><span class="n">std</span><span class="o">::</span><span class="n">exception_ptr</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">rethrow_exception</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">MyCustomException</span><span class="w"> </span><span class="o">&amp;</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">py</span><span class="o">::</span><span class="n">set_error</span><span class="p">(</span><span class="n">exc_storage</span><span class="p">.</span><span class="n">get_stored</span><span class="p">(),</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">());</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">OtherException</span><span class="w"> </span><span class="o">&amp;</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">py</span><span class="o">::</span><span class="n">set_error</span><span class="p">(</span><span class="n">PyExc_RuntimeError</span><span class="p">,</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">());</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">});</span>
</pre></div>
</div>
<p>Multiple exceptions can be handled by a single translator, as shown in the
example above. If the exception is not caught by the current translator, the
previously registered one gets a chance.</p>
<p>If none of the registered exception translators is able to handle the
exception, it is handled by the default converter as described in the previous
section.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>The file <code class="file docutils literal notranslate"><span class="pre">tests/test_exceptions.cpp</span></code> contains examples
of various custom exception translators and custom exception types.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Call <code class="docutils literal notranslate"><span class="pre">py::set_error()</span></code> for every exception caught in a custom exception
translator.  Failure to do so will cause Python to crash with <code class="docutils literal notranslate"><span class="pre">SystemError:</span>
<span class="pre">error</span> <span class="pre">return</span> <span class="pre">without</span> <span class="pre">exception</span> <span class="pre">set</span></code>.</p>
<p>Exceptions that you do not plan to handle should simply not be caught, or
may be explicitly (re-)thrown to delegate it to the other,
previously-declared existing exception translators.</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">libc++</span></code> and <code class="docutils literal notranslate"><span class="pre">libstdc++</span></code> <a class="reference external" href="https://stackoverflow.com/questions/19496643/using-clang-fvisibility-hidden-and-typeinfo-and-type-erasure/28827430">behave differently under macOS</a>
with <code class="docutils literal notranslate"><span class="pre">-fvisibility=hidden</span></code>. Therefore exceptions that are used across ABI
boundaries need to be explicitly exported, as exercised in
<code class="docutils literal notranslate"><span class="pre">tests/test_exceptions.h</span></code>. See also:
“Problems with C++ exceptions” under <a class="reference external" href="https://gcc.gnu.org/wiki/Visibility">GCC Wiki</a>.</p>
</div>
</section>
<section id="local-vs-global-exception-translators">
<h2>Local vs Global Exception Translators<a class="headerlink" href="#local-vs-global-exception-translators" title="Link to this heading"></a></h2>
<p>When a global exception translator is registered, it will be applied across all
modules in the reverse order of registration. This can create behavior where the
order of module import influences how exceptions are translated.</p>
<p>If module1 has the following translator:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">py</span><span class="o">::</span><span class="n">register_exception_translator</span><span class="p">([](</span><span class="n">std</span><span class="o">::</span><span class="n">exception_ptr</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">rethrow_exception</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">invalid_argument</span><span class="w"> </span><span class="o">&amp;</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">py</span><span class="o">::</span><span class="n">set_error</span><span class="p">(</span><span class="n">PyExc_ArgumentError</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;module1 handled this&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>and module2 has the following similar translator:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">py</span><span class="o">::</span><span class="n">register_exception_translator</span><span class="p">([](</span><span class="n">std</span><span class="o">::</span><span class="n">exception_ptr</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">rethrow_exception</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">invalid_argument</span><span class="w"> </span><span class="o">&amp;</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">py</span><span class="o">::</span><span class="n">set_error</span><span class="p">(</span><span class="n">PyExc_ArgumentError</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;module2 handled this&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>then which translator handles the invalid_argument will be determined by the
order that module1 and module2 are imported. Since exception translators are
applied in the reverse order of registration, which ever module was imported
last will “win” and that translator will be applied.</p>
<p>If there are multiple pybind11 modules that share exception types (either
standard built-in or custom) loaded into a single python instance and
consistent error handling behavior is needed, then local translators should be
used.</p>
<p>Changing the previous example to use <code class="docutils literal notranslate"><span class="pre">register_local_exception_translator</span></code>
would mean that when invalid_argument is thrown in the module2 code, the
module2 translator will always handle it, while in module1, the module1
translator will do the same.</p>
</section>
<section id="handling-exceptions-from-python-in-c">
<span id="handling-python-exceptions-cpp"></span><h2>Handling exceptions from Python in C++<a class="headerlink" href="#handling-exceptions-from-python-in-c" title="Link to this heading"></a></h2>
<p>When C++ calls Python functions, such as in a callback function or when
manipulating Python objects, and Python raises an <code class="docutils literal notranslate"><span class="pre">Exception</span></code>, pybind11
converts the Python exception into a C++ exception of type
<code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11::error_already_set</span></code> whose payload contains a C++ string textual
summary and the actual Python exception. <code class="docutils literal notranslate"><span class="pre">error_already_set</span></code> is used to
propagate Python exception back to Python (or possibly, handle them in C++).</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Exception raised in Python</p></th>
<th class="head"><p>Thrown as C++ exception type</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Any Python <code class="docutils literal notranslate"><span class="pre">Exception</span></code></p></td>
<td><p><code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11::error_already_set</span></code></p></td>
</tr>
</tbody>
</table>
<p>For example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// open(&quot;missing.txt&quot;, &quot;r&quot;)</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">py</span><span class="o">::</span><span class="n">module_</span><span class="o">::</span><span class="k">import</span><span class="p">(</span><span class="s">&quot;io&quot;</span><span class="p">).</span><span class="n">attr</span><span class="p">(</span><span class="s">&quot;open&quot;</span><span class="p">)(</span><span class="s">&quot;missing.txt&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;r&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">text</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">file</span><span class="p">.</span><span class="n">attr</span><span class="p">(</span><span class="s">&quot;read&quot;</span><span class="p">)();</span>
<span class="w">    </span><span class="n">file</span><span class="p">.</span><span class="n">attr</span><span class="p">(</span><span class="s">&quot;close&quot;</span><span class="p">)();</span>
<span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">error_already_set</span><span class="w"> </span><span class="o">&amp;</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">matches</span><span class="p">(</span><span class="n">PyExc_FileNotFoundError</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">py</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="s">&quot;missing.txt not found&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">matches</span><span class="p">(</span><span class="n">PyExc_PermissionError</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">py</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="s">&quot;missing.txt found but not accessible&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">throw</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that C++ to Python exception translation does not apply here, since that is
a method for translating C++ exceptions to Python, not vice versa. The error raised
from Python is always <code class="docutils literal notranslate"><span class="pre">error_already_set</span></code>.</p>
<p>This example illustrates this behavior:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">py</span><span class="o">::</span><span class="n">eval</span><span class="p">(</span><span class="s">&quot;raise ValueError(&#39;The Ring&#39;)&quot;</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">value_error</span><span class="w"> </span><span class="o">&amp;</span><span class="n">boromir</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Boromir never gets the ring</span>
<span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">error_already_set</span><span class="w"> </span><span class="o">&amp;</span><span class="n">frodo</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Frodo gets the ring</span>
<span class="w">    </span><span class="n">py</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="s">&quot;I will take the ring&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// py::value_error is a request for pybind11 to raise a Python exception</span>
<span class="w">    </span><span class="k">throw</span><span class="w"> </span><span class="n">py</span><span class="o">::</span><span class="n">value_error</span><span class="p">(</span><span class="s">&quot;The ball&quot;</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">error_already_set</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cat</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// cat won&#39;t catch the ball since</span>
<span class="w">    </span><span class="c1">// py::value_error is not a Python exception</span>
<span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">value_error</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dog</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// dog will catch the ball</span>
<span class="w">    </span><span class="n">py</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="s">&quot;Run Spot run&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">throw</span><span class="p">;</span><span class="w">  </span><span class="c1">// Throw it again (pybind11 will raise ValueError)</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="handling-errors-from-the-python-c-api">
<h2>Handling errors from the Python C API<a class="headerlink" href="#handling-errors-from-the-python-c-api" title="Link to this heading"></a></h2>
<p>Where possible, use <a class="reference internal" href="pycpp/object.html#wrappers"><span class="std std-ref">pybind11 wrappers</span></a> instead of calling
the Python C API directly. When calling the Python C API directly, in
addition to manually managing reference counts, one must follow the pybind11
error protocol, which is outlined here.</p>
<p>After calling the Python C API, if Python returns an error,
<code class="docutils literal notranslate"><span class="pre">throw</span> <span class="pre">py::error_already_set();</span></code>, which allows pybind11 to deal with the
exception and pass it back to the Python interpreter. This includes calls to
the error setting functions such as <code class="docutils literal notranslate"><span class="pre">py::set_error()</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">py</span><span class="o">::</span><span class="n">set_error</span><span class="p">(</span><span class="n">PyExc_TypeError</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;C API type error demo&quot;</span><span class="p">);</span>
<span class="k">throw</span><span class="w"> </span><span class="n">py</span><span class="o">::</span><span class="n">error_already_set</span><span class="p">();</span>

<span class="c1">// But it would be easier to simply...</span>
<span class="k">throw</span><span class="w"> </span><span class="n">py</span><span class="o">::</span><span class="n">type_error</span><span class="p">(</span><span class="s">&quot;pybind11 wrapper type error&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Alternately, to ignore the error, call <a class="reference external" href="https://docs.python.org/3/c-api/exceptions.html#c.PyErr_Clear">PyErr_Clear</a>.</p>
<p>Any Python error must be thrown or cleared, or Python/pybind11 will be left in
an invalid state.</p>
</section>
<section id="chaining-exceptions-raise-from">
<h2>Chaining exceptions (‘raise from’)<a class="headerlink" href="#chaining-exceptions-raise-from" title="Link to this heading"></a></h2>
<p>Python has a mechanism for indicating that exceptions were caused by other
exceptions:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">0</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;could not divide by zero&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">exc</span>
</pre></div>
</div>
<p>To do a similar thing in pybind11, you can use the <code class="docutils literal notranslate"><span class="pre">py::raise_from</span></code> function. It
sets the current python error indicator, so to continue propagating the exception
you should <code class="docutils literal notranslate"><span class="pre">throw</span> <span class="pre">py::error_already_set()</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">py</span><span class="o">::</span><span class="n">eval</span><span class="p">(</span><span class="s">&quot;print(1 / 0&quot;</span><span class="p">));</span>
<span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">error_already_set</span><span class="w"> </span><span class="o">&amp;</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">py</span><span class="o">::</span><span class="n">raise_from</span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="w"> </span><span class="n">PyExc_RuntimeError</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;could not divide by zero&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">throw</span><span class="w"> </span><span class="n">py</span><span class="o">::</span><span class="n">error_already_set</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 2.8.</span></p>
</div>
</section>
<section id="handling-unraisable-exceptions">
<span id="unraisable-exceptions"></span><h2>Handling unraisable exceptions<a class="headerlink" href="#handling-unraisable-exceptions" title="Link to this heading"></a></h2>
<p>If a Python function invoked from a C++ destructor or any function marked
<code class="docutils literal notranslate"><span class="pre">noexcept(true)</span></code> (collectively, “noexcept functions”) throws an exception, there
is no way to propagate the exception, as such functions may not throw.
Should they throw or fail to catch any exceptions in their call graph,
the C++ runtime calls <code class="docutils literal notranslate"><span class="pre">std::terminate()</span></code> to abort immediately.</p>
<p>Similarly, Python exceptions raised in a class’s <code class="docutils literal notranslate"><span class="pre">__del__</span></code> method do not
propagate, but are logged by Python as an unraisable error. In Python 3.8+, a
<a class="reference external" href="https://docs.python.org/3/library/sys.html#sys.unraisablehook">system hook is triggered</a>
and an auditing event is logged.</p>
<p>Any noexcept function should have a try-catch block that traps
class:<cite>error_already_set</cite> (or any other exception that can occur). Note that
pybind11 wrappers around Python exceptions such as
<code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11::value_error</span></code> are <em>not</em> Python exceptions; they are C++
exceptions that pybind11 catches and converts to Python exceptions. Noexcept
functions cannot propagate these exceptions either. A useful approach is to
convert them to Python exceptions and then <code class="docutils literal notranslate"><span class="pre">discard_as_unraisable</span></code> as shown
below.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">nonthrowing_func</span><span class="p">()</span><span class="w"> </span><span class="k">noexcept</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// ...</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">error_already_set</span><span class="w"> </span><span class="o">&amp;</span><span class="n">eas</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Discard the Python error using Python APIs, using the C++ magic</span>
<span class="w">        </span><span class="c1">// variable __func__. Python already knows the type and value and of the</span>
<span class="w">        </span><span class="c1">// exception object.</span>
<span class="w">        </span><span class="n">eas</span><span class="p">.</span><span class="n">discard_as_unraisable</span><span class="p">(</span><span class="n">__func__</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="w"> </span><span class="o">&amp;</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Log and discard C++ exceptions.</span>
<span class="w">        </span><span class="n">third_party</span><span class="o">::</span><span class="n">log</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 2.6.</span></p>
</div>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023-2025, EXP-code collaboration.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>