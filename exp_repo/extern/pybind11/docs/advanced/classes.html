<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Classes &mdash; EXP 0.172 documentation</title>
      <link rel="stylesheet" href="../../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../../../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../../../../../_static/copybutton.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../../../../_static/documentation_options.js?v=9c6809b7"></script>
        <script src="../../../../../_static/doctools.js?v=888ff710"></script>
        <script src="../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="../../../../../_static/clipboard.min.js?v=a7894cd8"></script>
        <script src="../../../../../_static/copybutton.js?v=5eb1bb1e"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../../index.html" class="icon icon-home">
            EXP
              <img src="../../../../../_static/exp_logo_white.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                7.x
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">First steps</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../intro/overview.html">EXP at a glance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../intro/install.html">Installation guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../intro/tutorial.html">Tutorials</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">EXP concepts</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../topics/bfetheory.html">BFE theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../topics/codeintro.html">Code intro</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../topics/timesseries.html">BFE time series analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../topics/multistep.html">N-Body optimization in EXP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../topics/centering.html">Centering</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../topics/yamlconfig.html">What is YAML?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../topics/yamlconfig.html#an-annotated-exp-yaml-configuration">An annotated EXP YAML configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../topics/howtosim.html">How to run your own N-body simulation in EXP</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Frequently Asked Questions (FAQ)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../faq.html">Are there pre-compiled versions of pyEXP and EXP?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../faq.html#i-only-want-pyexp-do-i-need-c-to-compile-exp">I only want pyEXP, do I need C++ to compile EXP?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../faq.html#why-would-i-use-exp-rather-than-pyexp">Why would I use EXP rather than pyEXP?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../faq.html#what-hardware-do-i-need-to-run-exp-and-pyexp">What hardware do I need to run EXP and pyEXP?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../faq.html#how-do-i-restart-exp-from-a-checkpoint">How do I restart EXP from a checkpoint?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../faq.html#my-hpc-cluster-does-not-have-the-required-dependencies-what-are-my-options">My HPC cluster does not have the required dependencies.  What are my options?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../faq.html#can-i-run-exp-or-pyexp-in-a-container">Can I run EXP or pyEXP in a container?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../faq.html#i-got-a-seg-fault-now-what-do-i-do">I got a “seg fault”, now what do I do?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../faq.html#how-can-i-do-a-calculation-with-phase-space-in-pyexp">How can I do a calculation with phase space in pyEXP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../faq.html#what-do-these-parameters-mean">What do these parameters mean?</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">How to solve specific problems</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../topics/visualizing-bases.html">How to visualize the BFE bases used to make your coefficients</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../topics/making-coefficients.html">How to  generate coefficients from phase-space snapshots</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../topics/saving-coefficients.html">How to save and reuse your newly generated coefficients</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../topics/visualizing-fields.html">How to convert your coefficients back to physical fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../topics/make-movies.html">Making movies of your BFE field quantities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../topics/using-mssa.html">How to use mSSA with your coefficient series in pyEXP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../topics/orbits.html">Generating orbits in your BFE potential fields</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../topics/replay.html">Replaying a simulation using EXP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../topics/exp-phase-space.html">The EXP phase-space format</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../topics/EXP-output.html">How the EXP N-body code selects what and when to write data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../topics/flatdisk.html">How to configure a razor-thin disk</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../topics/debug.html">Debugging EXP</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Extending EXP</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../topics/design.html">Software design goals and features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../topics/design.html#overall-organization-of-the-code">Overall organization of the code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../topics/design.html#parallel-usage">Parallel usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../topics/usermodules.html">User modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../topics/newforces.html">How to make a new EXP force</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">More about EXP</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../news.html">Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../contributing.html">Contributing to EXP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../doxygen.html">Index to C++ classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../pybind11.html">Index to pyEXP classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../versioning.html">Versioning and API stability</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../../index.html">EXP</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Classes</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../../_sources/exp_repo/extern/pybind11/docs/advanced/classes.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="classes">
<h1>Classes<a class="headerlink" href="#classes" title="Link to this heading"></a></h1>
<p>This section presents advanced binding code for classes and it is assumed
that you are already familiar with the basics from <span class="xref std std-doc">/classes</span>.</p>
<section id="overriding-virtual-functions-in-python">
<span id="overriding-virtuals"></span><h2>Overriding virtual functions in Python<a class="headerlink" href="#overriding-virtual-functions-in-python" title="Link to this heading"></a></h2>
<p>Suppose that a C++ class or interface has a virtual function that we’d like
to override from within Python (we’ll focus on the class <code class="docutils literal notranslate"><span class="pre">Animal</span></code>; <code class="docutils literal notranslate"><span class="pre">Dog</span></code> is
given as a specific example of how one would do this with traditional C++
code).</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Animal</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">Animal</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">go</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n_times</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Dog</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Animal</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">go</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n_times</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">n_times</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">            </span><span class="n">result</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&quot;woof! &quot;</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Let’s also suppose that we are given a plain function which calls the
function <code class="docutils literal notranslate"><span class="pre">go()</span></code> on an arbitrary <code class="docutils literal notranslate"><span class="pre">Animal</span></code> instance.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">call_go</span><span class="p">(</span><span class="n">Animal</span><span class="w"> </span><span class="o">*</span><span class="n">animal</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">animal</span><span class="o">-&gt;</span><span class="n">go</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Normally, the binding code for these classes would look as follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">PYBIND11_MODULE</span><span class="p">(</span><span class="n">example</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">Animal</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Animal&quot;</span><span class="p">)</span>
<span class="w">        </span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;go&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Animal</span><span class="o">::</span><span class="n">go</span><span class="p">);</span>

<span class="w">    </span><span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">Dog</span><span class="p">,</span><span class="w"> </span><span class="n">Animal</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Dog&quot;</span><span class="p">)</span>
<span class="w">        </span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">init</span><span class="o">&lt;&gt;</span><span class="p">());</span>

<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;call_go&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">call_go</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>However, these bindings are impossible to extend: <code class="docutils literal notranslate"><span class="pre">Animal</span></code> is not
constructible, and we clearly require some kind of “trampoline” that
redirects virtual calls back to Python.</p>
<p>Defining a new type of <code class="docutils literal notranslate"><span class="pre">Animal</span></code> from within Python is possible but requires a
helper class that is defined as follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">PyAnimal</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Animal</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="cm">/* Inherit the constructors */</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">Animal</span><span class="o">::</span><span class="n">Animal</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* Trampoline (need one for each virtual function) */</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">go</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n_times</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">PYBIND11_OVERRIDE_PURE</span><span class="p">(</span>
<span class="w">            </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="cm">/* Return type */</span>
<span class="w">            </span><span class="n">Animal</span><span class="p">,</span><span class="w">      </span><span class="cm">/* Parent class */</span>
<span class="w">            </span><span class="n">go</span><span class="p">,</span><span class="w">          </span><span class="cm">/* Name of function in C++ (must match Python name) */</span>
<span class="w">            </span><span class="n">n_times</span><span class="w">      </span><span class="cm">/* Argument(s) */</span>
<span class="w">        </span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The macro <code class="xref c c-macro docutils literal notranslate"><span class="pre">PYBIND11_OVERRIDE_PURE</span></code> should be used for pure virtual
functions, and <code class="xref c c-macro docutils literal notranslate"><span class="pre">PYBIND11_OVERRIDE</span></code> should be used for functions which have
a default implementation.  There are also two alternate macros
<code class="xref c c-macro docutils literal notranslate"><span class="pre">PYBIND11_OVERRIDE_PURE_NAME</span></code> and <code class="xref c c-macro docutils literal notranslate"><span class="pre">PYBIND11_OVERRIDE_NAME</span></code> which
take a string-valued name argument between the <em>Parent class</em> and <em>Name of the
function</em> slots, which defines the name of function in Python. This is required
when the C++ and Python versions of the
function have different names, e.g.  <code class="docutils literal notranslate"><span class="pre">operator()</span></code> vs <code class="docutils literal notranslate"><span class="pre">__call__</span></code>.</p>
<p>The binding code also needs a few minor adaptations (highlighted):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">PYBIND11_MODULE</span><span class="p">(</span><span class="n">example</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="hll"><span class="w">    </span><span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">Animal</span><span class="p">,</span><span class="w"> </span><span class="n">PyAnimal</span><span class="w"> </span><span class="cm">/* &lt;--- trampoline*/</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Animal&quot;</span><span class="p">)</span>
</span><span class="hll"><span class="w">        </span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">init</span><span class="o">&lt;&gt;</span><span class="p">())</span>
</span><span class="w">        </span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;go&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Animal</span><span class="o">::</span><span class="n">go</span><span class="p">);</span>

<span class="w">    </span><span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">Dog</span><span class="p">,</span><span class="w"> </span><span class="n">Animal</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Dog&quot;</span><span class="p">)</span>
<span class="w">        </span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">init</span><span class="o">&lt;&gt;</span><span class="p">());</span>

<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;call_go&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">call_go</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Importantly, pybind11 is made aware of the trampoline helper class by
specifying it as an extra template argument to <code class="xref py py-class docutils literal notranslate"><span class="pre">class_</span></code>. (This can also
be combined with other template arguments such as a custom holder type; the
order of template types does not matter).  Following this, we are able to
define a constructor as usual.</p>
<p>Bindings should be made against the actual class, not the trampoline helper class.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">Animal</span><span class="p">,</span><span class="w"> </span><span class="n">PyAnimal</span><span class="w"> </span><span class="cm">/* &lt;--- trampoline*/</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Animal&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">init</span><span class="o">&lt;&gt;</span><span class="p">())</span>
<span class="hll"><span class="w">    </span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;go&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">PyAnimal</span><span class="o">::</span><span class="n">go</span><span class="p">);</span><span class="w"> </span><span class="cm">/* &lt;--- THIS IS WRONG, use &amp;Animal::go */</span>
</span></pre></div>
</div>
<p>Note, however, that the above is sufficient for allowing python classes to
extend <code class="docutils literal notranslate"><span class="pre">Animal</span></code>, but not <code class="docutils literal notranslate"><span class="pre">Dog</span></code>: see <a class="reference internal" href="#virtual-and-inheritance"><span class="std std-ref">Combining virtual functions and inheritance</span></a> for the
necessary steps required to providing proper overriding support for inherited
classes.</p>
<p>The Python session below shows how to override <code class="docutils literal notranslate"><span class="pre">Animal::go</span></code> and invoke it via
a virtual method call.</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">example</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">Dog</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">call_go</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="go">&#39;woof! woof! woof! &#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">Cat</span><span class="p">(</span><span class="n">Animal</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span><span class="w"> </span><span class="nf">go</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_times</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="s2">&quot;meow! &quot;</span> <span class="o">*</span> <span class="n">n_times</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Cat</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">call_go</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="go">&#39;meow! meow! meow! &#39;</span>
</pre></div>
</div>
<p>If you are defining a custom constructor in a derived Python class, you <em>must</em>
ensure that you explicitly call the bound C++ constructor using <code class="docutils literal notranslate"><span class="pre">__init__</span></code>,
<em>regardless</em> of whether it is a default constructor or not. Otherwise, the
memory for the C++ portion of the instance will be left uninitialized, which
will generally leave the C++ instance in an invalid state and cause undefined
behavior if the C++ instance is subsequently used.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 2.6: </span>The default pybind11 metaclass will throw a <code class="docutils literal notranslate"><span class="pre">TypeError</span></code> when it detects
that <code class="docutils literal notranslate"><span class="pre">__init__</span></code> was not called by a derived class.</p>
</div>
<p>Here is an example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Dachshund</span><span class="p">(</span><span class="n">Dog</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="n">Dog</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>  <span class="c1"># Without this, a TypeError is raised.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">bark</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;yap!&quot;</span>
</pre></div>
</div>
<p>Note that a direct <code class="docutils literal notranslate"><span class="pre">__init__</span></code> constructor <em>should be called</em>, and <code class="docutils literal notranslate"><span class="pre">super()</span></code>
should not be used. For simple cases of linear inheritance, <code class="docutils literal notranslate"><span class="pre">super()</span></code>
may work, but once you begin mixing Python and C++ multiple inheritance,
things will fall apart due to differences between Python’s MRO and C++’s
mechanisms.</p>
<p>Please take a look at the <a class="reference internal" href="misc.html#macro-notes"><span class="std std-ref">General notes regarding convenience macros</span></a> before using this feature.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When the overridden type returns a reference or pointer to a type that
pybind11 converts from Python (for example, numeric values, std::string,
and other built-in value-converting types), there are some limitations to
be aware of:</p>
<ul class="simple">
<li><p>because in these cases there is no C++ variable to reference (the value
is stored in the referenced Python variable), pybind11 provides one in
the PYBIND11_OVERRIDE macros (when needed) with static storage duration.
Note that this means that invoking the overridden method on <em>any</em>
instance will change the referenced value stored in <em>all</em> instances of
that type.</p></li>
<li><p>Attempts to modify a non-const reference will not have the desired
effect: it will change only the static cache variable, but this change
will not propagate to underlying Python instance, and the change will be
replaced the next time the override is invoked.</p></li>
</ul>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The <code class="xref c c-macro docutils literal notranslate"><span class="pre">PYBIND11_OVERRIDE</span></code> and accompanying macros used to be called
<code class="docutils literal notranslate"><span class="pre">PYBIND11_OVERLOAD</span></code> up until pybind11 v2.5.0, and <code class="xref py py-func docutils literal notranslate"><span class="pre">get_override()</span></code>
used to be called <code class="docutils literal notranslate"><span class="pre">get_overload</span></code>. This naming was corrected and the older
macro and function names may soon be deprecated, in order to reduce
confusion with overloaded functions and methods and <code class="docutils literal notranslate"><span class="pre">py::overload_cast</span></code>
(see <a class="reference internal" href="../classes.html#classes"><span class="std std-ref">Object-oriented code</span></a>).</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>The file <code class="file docutils literal notranslate"><span class="pre">tests/test_virtual_functions.cpp</span></code> contains a complete
example that demonstrates how to override virtual functions using pybind11
in more detail.</p>
</div>
</section>
<section id="combining-virtual-functions-and-inheritance">
<span id="virtual-and-inheritance"></span><h2>Combining virtual functions and inheritance<a class="headerlink" href="#combining-virtual-functions-and-inheritance" title="Link to this heading"></a></h2>
<p>When combining virtual methods with inheritance, you need to be sure to provide
an override for each method for which you want to allow overrides from derived
python classes.  For example, suppose we extend the above <code class="docutils literal notranslate"><span class="pre">Animal</span></code>/<code class="docutils literal notranslate"><span class="pre">Dog</span></code>
example as follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Animal</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">go</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n_times</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">name</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;unknown&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Dog</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Animal</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">go</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n_times</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">n_times</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">            </span><span class="n">result</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">bark</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">bark</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;woof!&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>then the trampoline class for <code class="docutils literal notranslate"><span class="pre">Animal</span></code> must, as described in the previous
section, override <code class="docutils literal notranslate"><span class="pre">go()</span></code> and <code class="docutils literal notranslate"><span class="pre">name()</span></code>, but in order to allow python code to
inherit properly from <code class="docutils literal notranslate"><span class="pre">Dog</span></code>, we also need a trampoline class for <code class="docutils literal notranslate"><span class="pre">Dog</span></code> that
overrides both the added <code class="docutils literal notranslate"><span class="pre">bark()</span></code> method <em>and</em> the <code class="docutils literal notranslate"><span class="pre">go()</span></code> and <code class="docutils literal notranslate"><span class="pre">name()</span></code>
methods inherited from <code class="docutils literal notranslate"><span class="pre">Animal</span></code> (even though <code class="docutils literal notranslate"><span class="pre">Dog</span></code> doesn’t directly
override the <code class="docutils literal notranslate"><span class="pre">name()</span></code> method):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">PyAnimal</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Animal</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">Animal</span><span class="o">::</span><span class="n">Animal</span><span class="p">;</span><span class="w"> </span><span class="c1">// Inherit constructors</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">go</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n_times</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">PYBIND11_OVERRIDE_PURE</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="n">Animal</span><span class="p">,</span><span class="w"> </span><span class="n">go</span><span class="p">,</span><span class="w"> </span><span class="n">n_times</span><span class="p">);</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">name</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">PYBIND11_OVERRIDE</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="n">Animal</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>
<span class="k">class</span><span class="w"> </span><span class="nc">PyDog</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Dog</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">Dog</span><span class="o">::</span><span class="n">Dog</span><span class="p">;</span><span class="w"> </span><span class="c1">// Inherit constructors</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">go</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n_times</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">PYBIND11_OVERRIDE</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="n">Dog</span><span class="p">,</span><span class="w"> </span><span class="n">go</span><span class="p">,</span><span class="w"> </span><span class="n">n_times</span><span class="p">);</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">name</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">PYBIND11_OVERRIDE</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="n">Dog</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">bark</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">PYBIND11_OVERRIDE</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="n">Dog</span><span class="p">,</span><span class="w"> </span><span class="n">bark</span><span class="p">,</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Note the trailing commas in the <code class="docutils literal notranslate"><span class="pre">PYBIND11_OVERRIDE</span></code> calls to <code class="docutils literal notranslate"><span class="pre">name()</span></code>
and <code class="docutils literal notranslate"><span class="pre">bark()</span></code>. These are needed to portably implement a trampoline for a
function that does not take any arguments. For functions that take
a nonzero number of arguments, the trailing comma must be omitted.</p>
</div>
<p>A registered class derived from a pybind11-registered class with virtual
methods requires a similar trampoline class, <em>even if</em> it doesn’t explicitly
declare or override any virtual methods itself:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Husky</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Dog</span><span class="w"> </span><span class="p">{};</span>
<span class="k">class</span><span class="w"> </span><span class="nc">PyHusky</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Husky</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">Husky</span><span class="o">::</span><span class="n">Husky</span><span class="p">;</span><span class="w"> </span><span class="c1">// Inherit constructors</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">go</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n_times</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">PYBIND11_OVERRIDE_PURE</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="n">Husky</span><span class="p">,</span><span class="w"> </span><span class="n">go</span><span class="p">,</span><span class="w"> </span><span class="n">n_times</span><span class="p">);</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">name</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">PYBIND11_OVERRIDE</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="n">Husky</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">bark</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">PYBIND11_OVERRIDE</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="n">Husky</span><span class="p">,</span><span class="w"> </span><span class="n">bark</span><span class="p">,</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>There is, however, a technique that can be used to avoid this duplication
(which can be especially helpful for a base class with several virtual
methods).  The technique involves using template trampoline classes, as
follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">AnimalBase</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Animal</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">PyAnimal</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">AnimalBase</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">AnimalBase</span><span class="o">::</span><span class="n">AnimalBase</span><span class="p">;</span><span class="w"> </span><span class="c1">// Inherit constructors</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">go</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n_times</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">PYBIND11_OVERRIDE_PURE</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="n">AnimalBase</span><span class="p">,</span><span class="w"> </span><span class="n">go</span><span class="p">,</span><span class="w"> </span><span class="n">n_times</span><span class="p">);</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">name</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">PYBIND11_OVERRIDE</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="n">AnimalBase</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">class</span><span class="w"> </span><span class="nc">DogBase</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Dog</span><span class="o">&gt;</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">PyDog</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">PyAnimal</span><span class="o">&lt;</span><span class="n">DogBase</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">PyAnimal</span><span class="o">&lt;</span><span class="n">DogBase</span><span class="o">&gt;::</span><span class="n">PyAnimal</span><span class="p">;</span><span class="w"> </span><span class="c1">// Inherit constructors</span>
<span class="w">    </span><span class="c1">// Override PyAnimal&#39;s pure virtual go() with a non-pure one:</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">go</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n_times</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">PYBIND11_OVERRIDE</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="n">DogBase</span><span class="p">,</span><span class="w"> </span><span class="n">go</span><span class="p">,</span><span class="w"> </span><span class="n">n_times</span><span class="p">);</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">bark</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">PYBIND11_OVERRIDE</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="n">DogBase</span><span class="p">,</span><span class="w"> </span><span class="n">bark</span><span class="p">,</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>This technique has the advantage of requiring just one trampoline method to be
declared per virtual method and pure virtual method override.  It does,
however, require the compiler to generate at least as many methods (and
possibly more, if both pure virtual and overridden pure virtual methods are
exposed, as above).</p>
<p>The classes are then registered with pybind11 using:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">Animal</span><span class="p">,</span><span class="w"> </span><span class="n">PyAnimal</span><span class="o">&lt;&gt;&gt;</span><span class="w"> </span><span class="n">animal</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Animal&quot;</span><span class="p">);</span>
<span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">Dog</span><span class="p">,</span><span class="w"> </span><span class="n">Animal</span><span class="p">,</span><span class="w"> </span><span class="n">PyDog</span><span class="o">&lt;&gt;&gt;</span><span class="w"> </span><span class="n">dog</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Dog&quot;</span><span class="p">);</span>
<span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">Husky</span><span class="p">,</span><span class="w"> </span><span class="n">Dog</span><span class="p">,</span><span class="w"> </span><span class="n">PyDog</span><span class="o">&lt;</span><span class="n">Husky</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">husky</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Husky&quot;</span><span class="p">);</span>
<span class="c1">// ... add animal, dog, husky definitions</span>
</pre></div>
</div>
<p>Note that <code class="docutils literal notranslate"><span class="pre">Husky</span></code> did not require a dedicated trampoline template class at
all, since it neither declares any new virtual methods nor provides any pure
virtual method implementations.</p>
<p>With either the repeated-virtuals or templated trampoline methods in place, you
can now create a python class that inherits from <code class="docutils literal notranslate"><span class="pre">Dog</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">ShihTzu</span><span class="p">(</span><span class="n">Dog</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">bark</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;yip!&quot;</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>See the file <code class="file docutils literal notranslate"><span class="pre">tests/test_virtual_functions.cpp</span></code> for complete examples
using both the duplication and templated trampoline approaches.</p>
</div>
</section>
<section id="extended-trampoline-class-functionality">
<span id="extended-aliases"></span><h2>Extended trampoline class functionality<a class="headerlink" href="#extended-trampoline-class-functionality" title="Link to this heading"></a></h2>
<section id="forced-trampoline-class-initialisation">
<span id="extended-class-functionality-forced-trampoline"></span><h3>Forced trampoline class initialisation<a class="headerlink" href="#forced-trampoline-class-initialisation" title="Link to this heading"></a></h3>
<p>The trampoline classes described in the previous sections are, by default, only
initialized when needed.  More specifically, they are initialized when a python
class actually inherits from a registered type (instead of merely creating an
instance of the registered type), or when a registered constructor is only
valid for the trampoline class but not the registered class.  This is primarily
for performance reasons: when the trampoline class is not needed for anything
except virtual method dispatching, not initializing the trampoline class
improves performance by avoiding needing to do a run-time check to see if the
inheriting python instance has an overridden method.</p>
<p>Sometimes, however, it is useful to always initialize a trampoline class as an
intermediate class that does more than just handle virtual method dispatching.
For example, such a class might perform extra class initialization, extra
destruction operations, and might define new members and methods to enable a
more python-like interface to a class.</p>
<p>In order to tell pybind11 that it should <em>always</em> initialize the trampoline
class when creating new instances of a type, the class constructors should be
declared using <code class="docutils literal notranslate"><span class="pre">py::init_alias&lt;Args,</span> <span class="pre">...&gt;()</span></code> instead of the usual
<code class="docutils literal notranslate"><span class="pre">py::init&lt;Args,</span> <span class="pre">...&gt;()</span></code>.  This forces construction via the trampoline class,
ensuring member initialization and (eventual) destruction.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>See the file <code class="file docutils literal notranslate"><span class="pre">tests/test_virtual_functions.cpp</span></code> for complete examples
showing both normal and forced trampoline instantiation.</p>
</div>
</section>
<section id="different-method-signatures">
<h3>Different method signatures<a class="headerlink" href="#different-method-signatures" title="Link to this heading"></a></h3>
<p>The macro’s introduced in <a class="reference internal" href="#overriding-virtuals"><span class="std std-ref">Overriding virtual functions in Python</span></a> cover most of the standard
use cases when exposing C++ classes to Python. Sometimes it is hard or unwieldy
to create a direct one-on-one mapping between the arguments and method return
type.</p>
<p>An example would be when the C++ signature contains output arguments using
references (See also <a class="reference internal" href="../faq.html#faq-reference-arguments"><span class="std std-ref">Limitations involving reference arguments</span></a>). Another way of solving
this is to use the method body of the trampoline class to do conversions to the
input and return of the Python method.</p>
<p>The main building block to do so is the <code class="xref py py-func docutils literal notranslate"><span class="pre">get_override()</span></code>, this function
allows retrieving a method implemented in Python from within the trampoline’s
methods. Consider for example a C++ method which has the signature
<code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">myMethod(int32_t&amp;</span> <span class="pre">value)</span></code>, where the return indicates whether
something should be done with the <code class="docutils literal notranslate"><span class="pre">value</span></code>. This can be made convenient on the
Python side by allowing the Python function to return <code class="docutils literal notranslate"><span class="pre">None</span></code> or an <code class="docutils literal notranslate"><span class="pre">int</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="nf">MyClass::myMethod</span><span class="p">(</span><span class="kt">int32_t</span><span class="o">&amp;</span><span class="w"> </span><span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">pybind11</span><span class="o">::</span><span class="n">gil_scoped_acquire</span><span class="w"> </span><span class="n">gil</span><span class="p">;</span><span class="w">  </span><span class="c1">// Acquire the GIL while in this scope.</span>
<span class="w">    </span><span class="c1">// Try to look up the overridden method on the Python side.</span>
<span class="w">    </span><span class="n">pybind11</span><span class="o">::</span><span class="n">function</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pybind11</span><span class="o">::</span><span class="n">get_override</span><span class="p">(</span><span class="k">this</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;myMethod&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">override</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// method is found</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">obj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">override</span><span class="p">(</span><span class="n">value</span><span class="p">);</span><span class="w">  </span><span class="c1">// Call the Python function.</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">isinstance</span><span class="o">&lt;</span><span class="n">py</span><span class="o">::</span><span class="n">int_</span><span class="o">&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// check if it returned a Python integer type</span>
<span class="w">            </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">obj</span><span class="p">.</span><span class="n">cast</span><span class="o">&lt;</span><span class="kt">int32_t</span><span class="o">&gt;</span><span class="p">();</span><span class="w">  </span><span class="c1">// Cast it and assign it to the value.</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w">  </span><span class="c1">// Return true; value should be used.</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w">  </span><span class="c1">// Python returned none, return false.</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w">  </span><span class="c1">// Alternatively return MyClass::myMethod(value);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="custom-constructors">
<span id="id1"></span><h2>Custom constructors<a class="headerlink" href="#custom-constructors" title="Link to this heading"></a></h2>
<p>The syntax for binding constructors was previously introduced, but it only
works when a constructor of the appropriate arguments actually exists on the
C++ side.  To extend this to more general cases, pybind11 makes it possible
to bind factory functions as constructors. For example, suppose you have a
class like this:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Example</span><span class="w"> </span><span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="n">Example</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span><span class="w"> </span><span class="c1">// private constructor</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="c1">// Factory function:</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">Example</span><span class="w"> </span><span class="n">create</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">Example</span><span class="p">(</span><span class="n">a</span><span class="p">);</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>

<span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">Example</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Example&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Example</span><span class="o">::</span><span class="n">create</span><span class="p">));</span>
</pre></div>
</div>
<p>While it is possible to create a straightforward binding of the static
<code class="docutils literal notranslate"><span class="pre">create</span></code> method, it may sometimes be preferable to expose it as a constructor
on the Python side. This can be accomplished by calling <code class="docutils literal notranslate"><span class="pre">.def(py::init(...))</span></code>
with the function reference returning the new instance passed as an argument.
It is also possible to use this approach to bind a function returning a new
instance by raw pointer or by the holder (e.g. <code class="docutils literal notranslate"><span class="pre">std::unique_ptr</span></code>).</p>
<p>The following example shows the different approaches:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Example</span><span class="w"> </span><span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="n">Example</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span><span class="w"> </span><span class="c1">// private constructor</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="c1">// Factory function - returned by value:</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">Example</span><span class="w"> </span><span class="n">create</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">Example</span><span class="p">(</span><span class="n">a</span><span class="p">);</span><span class="w"> </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// These constructors are publicly callable:</span>
<span class="w">    </span><span class="n">Example</span><span class="p">(</span><span class="kt">double</span><span class="p">);</span>
<span class="w">    </span><span class="n">Example</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span>
<span class="w">    </span><span class="n">Example</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">);</span>
<span class="p">};</span>

<span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">Example</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Example&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="c1">// Bind the factory function as a constructor:</span>
<span class="w">    </span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Example</span><span class="o">::</span><span class="n">create</span><span class="p">))</span>
<span class="w">    </span><span class="c1">// Bind a lambda function returning a pointer wrapped in a holder:</span>
<span class="w">    </span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">init</span><span class="p">([](</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">arg</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Example</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">Example</span><span class="p">(</span><span class="n">arg</span><span class="p">));</span>
<span class="w">    </span><span class="p">}))</span>
<span class="w">    </span><span class="c1">// Return a raw pointer:</span>
<span class="w">    </span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">init</span><span class="p">([](</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Example</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">);</span><span class="w"> </span><span class="p">}))</span>
<span class="w">    </span><span class="c1">// You can mix the above with regular C++ constructor bindings as well:</span>
<span class="w">    </span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">init</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">())</span>
<span class="w">    </span><span class="p">;</span>
</pre></div>
</div>
<p>When the constructor is invoked from Python, pybind11 will call the factory
function and store the resulting C++ instance in the Python instance.</p>
<p>When combining factory functions constructors with <a class="reference internal" href="#overriding-virtuals"><span class="std std-ref">virtual function
trampolines</span></a> there are two approaches.  The first is to
add a constructor to the alias class that takes a base value by
rvalue-reference.  If such a constructor is available, it will be used to
construct an alias instance from the value returned by the factory function.
The second option is to provide two factory functions to <code class="docutils literal notranslate"><span class="pre">py::init()</span></code>: the
first will be invoked when no alias class is required (i.e. when the class is
being used but not inherited from in Python), and the second will be invoked
when an alias is required.</p>
<p>You can also specify a single factory function that always returns an alias
instance: this will result in behaviour similar to <code class="docutils literal notranslate"><span class="pre">py::init_alias&lt;...&gt;()</span></code>,
as described in the <a class="reference internal" href="#extended-aliases"><span class="std std-ref">extended trampoline class documentation</span></a>.</p>
<p>The following example shows the different factory approaches for a class with
an alias:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pybind11/factory.h&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Example</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">Example</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">class</span><span class="w"> </span><span class="nc">PyExample</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Example</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">Example</span><span class="o">::</span><span class="n">Example</span><span class="p">;</span>
<span class="w">    </span><span class="n">PyExample</span><span class="p">(</span><span class="n">Example</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="n">base</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Example</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">base</span><span class="p">))</span><span class="w"> </span><span class="p">{}</span>
<span class="p">};</span>
<span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">Example</span><span class="p">,</span><span class="w"> </span><span class="n">PyExample</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Example&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="c1">// Returns an Example pointer.  If a PyExample is needed, the Example</span>
<span class="w">    </span><span class="c1">// instance will be moved via the extra constructor in PyExample, above.</span>
<span class="w">    </span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">init</span><span class="p">([]()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Example</span><span class="p">();</span><span class="w"> </span><span class="p">}))</span>
<span class="w">    </span><span class="c1">// Two callbacks:</span>
<span class="w">    </span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">init</span><span class="p">([]()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Example</span><span class="p">();</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="cm">/* no alias needed */</span><span class="p">,</span>
<span class="w">                  </span><span class="p">[]()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">PyExample</span><span class="p">();</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="cm">/* alias needed */</span><span class="p">))</span>
<span class="w">    </span><span class="c1">// *Always* returns an alias instance (like py::init_alias&lt;&gt;())</span>
<span class="w">    </span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">init</span><span class="p">([]()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">PyExample</span><span class="p">();</span><span class="w"> </span><span class="p">}))</span>
<span class="w">    </span><span class="p">;</span>
</pre></div>
</div>
<section id="brace-initialization">
<h3>Brace initialization<a class="headerlink" href="#brace-initialization" title="Link to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">pybind11::init&lt;&gt;</span></code> internally uses C++11 brace initialization to call the
constructor of the target class. This means that it can be used to bind
<em>implicit</em> constructors as well:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">Aggregate</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">Aggregate</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Aggregate&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">init</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;&gt;</span><span class="p">());</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Note that brace initialization preferentially invokes constructor overloads
taking a <code class="docutils literal notranslate"><span class="pre">std::initializer_list</span></code>. In the rare event that this causes an
issue, you can work around it by using <code class="docutils literal notranslate"><span class="pre">py::init(...)</span></code> with a lambda
function that constructs the new object as desired.</p>
</div>
</section>
</section>
<section id="non-public-destructors">
<span id="classes-with-non-public-destructors"></span><h2>Non-public destructors<a class="headerlink" href="#non-public-destructors" title="Link to this heading"></a></h2>
<p>If a class has a private or protected destructor (as might e.g. be the case in
a singleton pattern), a compile error will occur when creating bindings via
pybind11. The underlying issue is that the <code class="docutils literal notranslate"><span class="pre">std::unique_ptr</span></code> holder type that
is responsible for managing the lifetime of instances will reference the
destructor even if no deallocations ever take place. In order to expose classes
with private or protected destructors, it is possible to override the holder
type via a holder type argument to <code class="docutils literal notranslate"><span class="pre">class_</span></code>. Pybind11 provides a helper class
<code class="docutils literal notranslate"><span class="pre">py::nodelete</span></code> that disables any destructor invocations. In this case, it is
crucial that instances are deallocated on the C++ side to avoid memory leaks.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/* ... definition ... */</span>

<span class="k">class</span><span class="w"> </span><span class="nc">MyClass</span><span class="w"> </span><span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="o">~</span><span class="n">MyClass</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>

<span class="cm">/* ... binding code ... */</span>

<span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">MyClass</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">MyClass</span><span class="p">,</span><span class="w"> </span><span class="n">py</span><span class="o">::</span><span class="n">nodelete</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;MyClass&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">init</span><span class="o">&lt;&gt;</span><span class="p">())</span>
</pre></div>
</div>
</section>
<section id="destructors-that-call-python">
<span id="id2"></span><h2>Destructors that call Python<a class="headerlink" href="#destructors-that-call-python" title="Link to this heading"></a></h2>
<p>If a Python function is invoked from a C++ destructor, an exception may be thrown
of type <code class="xref py py-class docutils literal notranslate"><span class="pre">error_already_set</span></code>. If this error is thrown out of a class destructor,
<code class="docutils literal notranslate"><span class="pre">std::terminate()</span></code> will be called, terminating the process. Class destructors
must catch all exceptions of type <code class="xref py py-class docutils literal notranslate"><span class="pre">error_already_set</span></code> to discard the Python
exception using <code class="xref py py-func docutils literal notranslate"><span class="pre">error_already_set::discard_as_unraisable()</span></code>.</p>
<p>Every Python function should be treated as <em>possibly throwing</em>. When a Python generator
stops yielding items, Python will throw a <code class="docutils literal notranslate"><span class="pre">StopIteration</span></code> exception, which can pass
though C++ destructors if the generator’s stack frame holds the last reference to C++
objects.</p>
<p>For more information, see <a class="reference internal" href="exceptions.html#unraisable-exceptions"><span class="std std-ref">the documentation on exceptions</span></a>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MyClass</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="o">~</span><span class="n">MyClass</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">py</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="s">&quot;Even printing is dangerous in a destructor&quot;</span><span class="p">);</span>
<span class="w">            </span><span class="n">py</span><span class="o">::</span><span class="n">exec</span><span class="p">(</span><span class="s">&quot;raise ValueError(&#39;This is an unraisable exception&#39;)&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">error_already_set</span><span class="w"> </span><span class="o">&amp;</span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// error_context should be information about where/why the occurred,</span>
<span class="w">            </span><span class="c1">// e.g. use __func__ to get the name of the current function</span>
<span class="w">            </span><span class="n">e</span><span class="p">.</span><span class="n">discard_as_unraisable</span><span class="p">(</span><span class="n">__func__</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>pybind11 does not support C++ destructors marked <code class="docutils literal notranslate"><span class="pre">noexcept(false)</span></code>.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 2.6.</span></p>
</div>
</section>
<section id="implicit-conversions">
<span id="id3"></span><h2>Implicit conversions<a class="headerlink" href="#implicit-conversions" title="Link to this heading"></a></h2>
<p>Suppose that instances of two types <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code> are used in a project, and
that an <code class="docutils literal notranslate"><span class="pre">A</span></code> can easily be converted into an instance of type <code class="docutils literal notranslate"><span class="pre">B</span></code> (examples of this
could be a fixed and an arbitrary precision number type).</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;A&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="c1">/// ... members ...</span>

<span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;B&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">init</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">())</span>
<span class="w">    </span><span class="c1">/// ... members ...</span>

<span class="n">m</span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;func&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="p">[](</span><span class="k">const</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* .... */</span><span class="w"> </span><span class="p">}</span>
<span class="p">);</span>
</pre></div>
</div>
<p>To invoke the function <code class="docutils literal notranslate"><span class="pre">func</span></code> using a variable <code class="docutils literal notranslate"><span class="pre">a</span></code> containing an <code class="docutils literal notranslate"><span class="pre">A</span></code>
instance, we’d have to write <code class="docutils literal notranslate"><span class="pre">func(B(a))</span></code> in Python. On the other hand, C++
will automatically apply an implicit type conversion, which makes it possible
to directly write <code class="docutils literal notranslate"><span class="pre">func(a)</span></code>.</p>
<p>In this situation (i.e. where <code class="docutils literal notranslate"><span class="pre">B</span></code> has a constructor that converts from
<code class="docutils literal notranslate"><span class="pre">A</span></code>), the following statement enables similar implicit conversions on the
Python side:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">py</span><span class="o">::</span><span class="n">implicitly_convertible</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="o">&gt;</span><span class="p">();</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Implicit conversions from <code class="docutils literal notranslate"><span class="pre">A</span></code> to <code class="docutils literal notranslate"><span class="pre">B</span></code> only work when <code class="docutils literal notranslate"><span class="pre">B</span></code> is a custom
data type that is exposed to Python via pybind11.</p>
<p>To prevent runaway recursion, implicit conversions are non-reentrant: an
implicit conversion invoked as part of another implicit conversion of the
same type (i.e. from <code class="docutils literal notranslate"><span class="pre">A</span></code> to <code class="docutils literal notranslate"><span class="pre">B</span></code>) will fail.</p>
</div>
</section>
<section id="static-properties">
<span id="id4"></span><h2>Static properties<a class="headerlink" href="#static-properties" title="Link to this heading"></a></h2>
<p>The section on <a class="reference internal" href="../classes.html#properties"><span class="std std-ref">Instance and static fields</span></a> discussed the creation of instance properties
that are implemented in terms of C++ getters and setters.</p>
<p>Static properties can also be created in a similar way to expose getters and
setters of static class attributes. Note that the implicit <code class="docutils literal notranslate"><span class="pre">self</span></code> argument
also exists in this case and is used to pass the Python <code class="docutils literal notranslate"><span class="pre">type</span></code> subclass
instance. This parameter will often not be needed by the C++ side, and the
following example illustrates how to instantiate a lambda getter function
that ignores it:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Foo&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">def_property_readonly_static</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">[](</span><span class="n">py</span><span class="o">::</span><span class="n">object</span><span class="w"> </span><span class="cm">/* self */</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">Foo</span><span class="p">();</span><span class="w"> </span><span class="p">});</span>
</pre></div>
</div>
</section>
<section id="operator-overloading">
<h2>Operator overloading<a class="headerlink" href="#operator-overloading" title="Link to this heading"></a></h2>
<p>Suppose that we’re given the following <code class="docutils literal notranslate"><span class="pre">Vector2</span></code> class with a vector addition
and scalar multiplication operation, all implemented using overloaded operators
in C++.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Vector2</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">Vector2</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="w"> </span><span class="n">y</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span>

<span class="w">    </span><span class="n">Vector2</span><span class="w"> </span><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Vector2</span><span class="w"> </span><span class="o">&amp;</span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">Vector2</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">y</span><span class="p">);</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="n">Vector2</span><span class="w"> </span><span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">Vector2</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">value</span><span class="p">);</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="n">Vector2</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Vector2</span><span class="w"> </span><span class="o">&amp;</span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">y</span><span class="p">;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="n">Vector2</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">*=</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">v</span><span class="p">;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">v</span><span class="p">;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="w">    </span><span class="k">friend</span><span class="w"> </span><span class="n">Vector2</span><span class="w"> </span><span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Vector2</span><span class="w"> </span><span class="o">&amp;</span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">Vector2</span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">toString</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;[&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot;]&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The following snippet shows how the above operators can be conveniently exposed
to Python.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;pybind11/operators.h&gt;</span>

<span class="n">PYBIND11_MODULE</span><span class="p">(</span><span class="n">example</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">Vector2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Vector2&quot;</span><span class="p">)</span>
<span class="w">        </span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">init</span><span class="o">&lt;</span><span class="kt">float</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">&gt;</span><span class="p">())</span>
<span class="w">        </span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">self</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">py</span><span class="o">::</span><span class="n">self</span><span class="p">)</span>
<span class="w">        </span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">self</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">py</span><span class="o">::</span><span class="n">self</span><span class="p">)</span>
<span class="w">        </span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">self</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="kt">float</span><span class="p">())</span>
<span class="w">        </span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="kt">float</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">py</span><span class="o">::</span><span class="n">self</span><span class="p">)</span>
<span class="w">        </span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">self</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="kt">float</span><span class="p">())</span>
<span class="w">        </span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="o">-</span><span class="n">py</span><span class="o">::</span><span class="n">self</span><span class="p">)</span>
<span class="w">        </span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;__repr__&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Vector2</span><span class="o">::</span><span class="n">toString</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that a line like</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">self</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="kt">float</span><span class="p">())</span>
</pre></div>
</div>
<p>is really just short hand notation for</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;__mul__&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">[](</span><span class="k">const</span><span class="w"> </span><span class="n">Vector2</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="p">},</span><span class="w"> </span><span class="n">py</span><span class="o">::</span><span class="n">is_operator</span><span class="p">())</span>
</pre></div>
</div>
<p>This can be useful for exposing additional operators that don’t exist on the
C++ side, or to perform other types of customization. The <code class="docutils literal notranslate"><span class="pre">py::is_operator</span></code>
flag marker is needed to inform pybind11 that this is an operator, which
returns <code class="docutils literal notranslate"><span class="pre">NotImplemented</span></code> when invoked with incompatible arguments rather than
throwing a type error.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To use the more convenient <code class="docutils literal notranslate"><span class="pre">py::self</span></code> notation, the additional
header file <code class="file docutils literal notranslate"><span class="pre">pybind11/operators.h</span></code> must be included.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>The file <code class="file docutils literal notranslate"><span class="pre">tests/test_operator_overloading.cpp</span></code> contains a
complete example that demonstrates how to work with overloaded operators in
more detail.</p>
</div>
</section>
<section id="pickling-support">
<span id="pickling"></span><h2>Pickling support<a class="headerlink" href="#pickling-support" title="Link to this heading"></a></h2>
<p>Python’s <code class="docutils literal notranslate"><span class="pre">pickle</span></code> module provides a powerful facility to serialize and
de-serialize a Python object graph into a binary data stream. To pickle and
unpickle C++ classes using pybind11, a <code class="docutils literal notranslate"><span class="pre">py::pickle()</span></code> definition must be
provided. Suppose the class in question has the following signature:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Pickleable</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">Pickleable</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">m_value</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">value</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">m_value</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">setExtra</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">extra</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">m_extra</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">extra</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">extra</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">m_extra</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">m_value</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">m_extra</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Pickling support in Python is enabled by defining the <code class="docutils literal notranslate"><span class="pre">__setstate__</span></code> and
<code class="docutils literal notranslate"><span class="pre">__getstate__</span></code> methods <a class="footnote-reference brackets" href="#f3" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>. For pybind11 classes, use <code class="docutils literal notranslate"><span class="pre">py::pickle()</span></code>
to bind these two functions:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">Pickleable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Pickleable&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">init</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">())</span>
<span class="w">    </span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;value&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Pickleable</span><span class="o">::</span><span class="n">value</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;extra&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Pickleable</span><span class="o">::</span><span class="n">extra</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;setExtra&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Pickleable</span><span class="o">::</span><span class="n">setExtra</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">pickle</span><span class="p">(</span>
<span class="w">        </span><span class="p">[](</span><span class="k">const</span><span class="w"> </span><span class="n">Pickleable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// __getstate__</span>
<span class="w">            </span><span class="cm">/* Return a tuple that fully encodes the state of the object */</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">py</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">value</span><span class="p">(),</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">extra</span><span class="p">());</span>
<span class="w">        </span><span class="p">},</span>
<span class="w">        </span><span class="p">[](</span><span class="n">py</span><span class="o">::</span><span class="n">tuple</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// __setstate__</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="w">                </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;Invalid state!&quot;</span><span class="p">);</span>

<span class="w">            </span><span class="cm">/* Create a new C++ instance */</span>
<span class="w">            </span><span class="n">Pickleable</span><span class="w"> </span><span class="nf">p</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">());</span>

<span class="w">            </span><span class="cm">/* Assign any additional state */</span>
<span class="w">            </span><span class="n">p</span><span class="p">.</span><span class="n">setExtra</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span>

<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">));</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">__setstate__</span></code> part of the <code class="docutils literal notranslate"><span class="pre">py::pickle()</span></code> definition follows the same
rules as the single-argument version of <code class="docutils literal notranslate"><span class="pre">py::init()</span></code>. The return type can be
a value, pointer or holder type. See <a class="reference internal" href="#custom-constructors"><span class="std std-ref">Custom constructors</span></a> for details.</p>
<p>An instance can now be pickled as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pickle</span>

<span class="n">p</span> <span class="o">=</span> <span class="n">Pickleable</span><span class="p">(</span><span class="s2">&quot;test_value&quot;</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">setExtra</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If given, the second argument to <code class="docutils literal notranslate"><span class="pre">dumps</span></code> must be 2 or larger - 0 and 1 are
not supported. Newer versions are also fine; for instance, specify <code class="docutils literal notranslate"><span class="pre">-1</span></code> to
always use the latest available version. Beware: failure to follow these
instructions will cause important pybind11 memory allocation routines to be
skipped during unpickling, which will likely lead to memory corruption
and/or segmentation faults. Python defaults to version 3 (Python 3-3.7) and
version 4 for Python 3.8+.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>The file <code class="file docutils literal notranslate"><span class="pre">tests/test_pickling.cpp</span></code> contains a complete example
that demonstrates how to pickle and unpickle types using pybind11 in more
detail.</p>
</div>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="f3" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id5">1</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="http://docs.python.org/3/library/pickle.html#pickling-class-instances">http://docs.python.org/3/library/pickle.html#pickling-class-instances</a></p>
</aside>
</aside>
</section>
<section id="deepcopy-support">
<h2>Deepcopy support<a class="headerlink" href="#deepcopy-support" title="Link to this heading"></a></h2>
<p>Python normally uses references in assignments. Sometimes a real copy is needed
to prevent changing all copies. The <code class="docutils literal notranslate"><span class="pre">copy</span></code> module <a class="footnote-reference brackets" href="#f5" id="id6" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a> provides these
capabilities.</p>
<p>A class with pickle support is automatically also (deep)copy
compatible. However, performance can be improved by adding custom
<code class="docutils literal notranslate"><span class="pre">__copy__</span></code> and <code class="docutils literal notranslate"><span class="pre">__deepcopy__</span></code> methods.</p>
<p>For simple classes (deep)copy can be enabled by using the copy constructor,
which should look as follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">Copyable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Copyable&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;__copy__&quot;</span><span class="p">,</span><span class="w">  </span><span class="p">[](</span><span class="k">const</span><span class="w"> </span><span class="n">Copyable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">Copyable</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
<span class="w">    </span><span class="p">})</span>
<span class="w">    </span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;__deepcopy__&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">[](</span><span class="k">const</span><span class="w"> </span><span class="n">Copyable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="n">py</span><span class="o">::</span><span class="n">dict</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">Copyable</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
<span class="w">    </span><span class="p">},</span><span class="w"> </span><span class="s">&quot;memo&quot;</span><span class="n">_a</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Dynamic attributes will not be copied in this example.</p>
</div>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="f5" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id6">2</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://docs.python.org/3/library/copy.html">https://docs.python.org/3/library/copy.html</a></p>
</aside>
</aside>
</section>
<section id="multiple-inheritance">
<h2>Multiple Inheritance<a class="headerlink" href="#multiple-inheritance" title="Link to this heading"></a></h2>
<p>pybind11 can create bindings for types that derive from multiple base types
(aka. <em>multiple inheritance</em>). To do so, specify all bases in the template
arguments of the <code class="docutils literal notranslate"><span class="pre">class_</span></code> declaration:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">MyType</span><span class="p">,</span><span class="w"> </span><span class="n">BaseType1</span><span class="p">,</span><span class="w"> </span><span class="n">BaseType2</span><span class="p">,</span><span class="w"> </span><span class="n">BaseType3</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;MyType&quot;</span><span class="p">)</span>
<span class="w">   </span><span class="p">...</span>
</pre></div>
</div>
<p>The base types can be specified in arbitrary order, and they can even be
interspersed with alias types and holder types (discussed earlier in this
document)—pybind11 will automatically find out which is which. The only
requirement is that the first template argument is the type to be declared.</p>
<p>It is also permitted to inherit multiply from exported C++ classes in Python,
as well as inheriting from multiple Python and/or pybind11-exported classes.</p>
<p>There is one caveat regarding the implementation of this feature:</p>
<p>When only one base type is specified for a C++ type that actually has multiple
bases, pybind11 will assume that it does not participate in multiple
inheritance, which can lead to undefined behavior. In such cases, add the tag
<code class="docutils literal notranslate"><span class="pre">multiple_inheritance</span></code> to the class constructor:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">MyType</span><span class="p">,</span><span class="w"> </span><span class="n">BaseType2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;MyType&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">py</span><span class="o">::</span><span class="n">multiple_inheritance</span><span class="p">());</span>
</pre></div>
</div>
<p>The tag is redundant and does not need to be specified when multiple base types
are listed.</p>
</section>
<section id="module-local-class-bindings">
<span id="module-local"></span><h2>Module-local class bindings<a class="headerlink" href="#module-local-class-bindings" title="Link to this heading"></a></h2>
<p>When creating a binding for a class, pybind11 by default makes that binding
“global” across modules.  What this means is that a type defined in one module
can be returned from any module resulting in the same Python type.  For
example, this allows the following:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// In the module1.cpp binding code for module1:</span>
<span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">Pet</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Pet&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">init</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">())</span>
<span class="w">    </span><span class="p">.</span><span class="n">def_readonly</span><span class="p">(</span><span class="s">&quot;name&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Pet</span><span class="o">::</span><span class="n">name</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// In the module2.cpp binding code for module2:</span>
<span class="n">m</span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;create_pet&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">[](</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Pet</span><span class="p">(</span><span class="n">name</span><span class="p">);</span><span class="w"> </span><span class="p">});</span>
</pre></div>
</div>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">module1</span><span class="w"> </span><span class="kn">import</span> <span class="n">Pet</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">module2</span><span class="w"> </span><span class="kn">import</span> <span class="n">create_pet</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pet1</span> <span class="o">=</span> <span class="n">Pet</span><span class="p">(</span><span class="s2">&quot;Kitty&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pet2</span> <span class="o">=</span> <span class="n">create_pet</span><span class="p">(</span><span class="s2">&quot;Doggy&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pet2</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>
<span class="go">&#39;Doggy&#39;</span>
</pre></div>
</div>
<p>When writing binding code for a library, this is usually desirable: this
allows, for example, splitting up a complex library into multiple Python
modules.</p>
<p>In some cases, however, this can cause conflicts.  For example, suppose two
unrelated modules make use of an external C++ library and each provide custom
bindings for one of that library’s classes.  This will result in an error when
a Python program attempts to import both modules (directly or indirectly)
because of conflicting definitions on the external type:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// dogs.cpp</span>

<span class="c1">// Binding for external library class:</span>
<span class="n">py</span><span class="o">::</span><span class="k">class</span><span class="o">&lt;</span><span class="n">pets</span><span class="o">::</span><span class="n">Pet</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Pet&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;name&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pets</span><span class="o">::</span><span class="n">Pet</span><span class="o">::</span><span class="n">name</span><span class="p">);</span>

<span class="c1">// Binding for local extension class:</span>
<span class="n">py</span><span class="o">::</span><span class="k">class</span><span class="o">&lt;</span><span class="n">Dog</span><span class="p">,</span><span class="w"> </span><span class="n">pets</span><span class="o">::</span><span class="n">Pet</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Dog&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">init</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">());</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// cats.cpp, in a completely separate project from the above dogs.cpp.</span>

<span class="c1">// Binding for external library class:</span>
<span class="n">py</span><span class="o">::</span><span class="k">class</span><span class="o">&lt;</span><span class="n">pets</span><span class="o">::</span><span class="n">Pet</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Pet&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;get_name&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pets</span><span class="o">::</span><span class="n">Pet</span><span class="o">::</span><span class="n">name</span><span class="p">);</span>

<span class="c1">// Binding for local extending class:</span>
<span class="n">py</span><span class="o">::</span><span class="k">class</span><span class="o">&lt;</span><span class="n">Cat</span><span class="p">,</span><span class="w"> </span><span class="n">pets</span><span class="o">::</span><span class="n">Pet</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Cat&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">init</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">());</span>
</pre></div>
</div>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">cats</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">dogs</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">ImportError</span>: <span class="n">generic_type: type &quot;Pet&quot; is already registered!</span>
</pre></div>
</div>
<p>To get around this, you can tell pybind11 to keep the external class binding
localized to the module by passing the <code class="docutils literal notranslate"><span class="pre">py::module_local()</span></code> attribute into
the <code class="docutils literal notranslate"><span class="pre">py::class_</span></code> constructor:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Pet binding in dogs.cpp:</span>
<span class="n">py</span><span class="o">::</span><span class="k">class</span><span class="o">&lt;</span><span class="n">pets</span><span class="o">::</span><span class="n">Pet</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Pet&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">py</span><span class="o">::</span><span class="n">module_local</span><span class="p">())</span>
<span class="w">    </span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;name&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pets</span><span class="o">::</span><span class="n">Pet</span><span class="o">::</span><span class="n">name</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Pet binding in cats.cpp:</span>
<span class="n">py</span><span class="o">::</span><span class="k">class</span><span class="o">&lt;</span><span class="n">pets</span><span class="o">::</span><span class="n">Pet</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Pet&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">py</span><span class="o">::</span><span class="n">module_local</span><span class="p">())</span>
<span class="w">    </span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;get_name&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pets</span><span class="o">::</span><span class="n">Pet</span><span class="o">::</span><span class="n">name</span><span class="p">);</span>
</pre></div>
</div>
<p>This makes the Python-side <code class="docutils literal notranslate"><span class="pre">dogs.Pet</span></code> and <code class="docutils literal notranslate"><span class="pre">cats.Pet</span></code> into distinct classes,
avoiding the conflict and allowing both modules to be loaded.  C++ code in the
<code class="docutils literal notranslate"><span class="pre">dogs</span></code> module that casts or returns a <code class="docutils literal notranslate"><span class="pre">Pet</span></code> instance will result in a
<code class="docutils literal notranslate"><span class="pre">dogs.Pet</span></code> Python instance, while C++ code in the <code class="docutils literal notranslate"><span class="pre">cats</span></code> module will result
in a <code class="docutils literal notranslate"><span class="pre">cats.Pet</span></code> Python instance.</p>
<p>This does come with two caveats, however: First, external modules cannot return
or cast a <code class="docutils literal notranslate"><span class="pre">Pet</span></code> instance to Python (unless they also provide their own local
bindings).  Second, from the Python point of view they are two distinct classes.</p>
<p>Note that the locality only applies in the C++ -&gt; Python direction.  When
passing such a <code class="docutils literal notranslate"><span class="pre">py::module_local</span></code> type into a C++ function, the module-local
classes are still considered.  This means that if the following function is
added to any module (including but not limited to the <code class="docutils literal notranslate"><span class="pre">cats</span></code> and <code class="docutils literal notranslate"><span class="pre">dogs</span></code>
modules above) it will be callable with either a <code class="docutils literal notranslate"><span class="pre">dogs.Pet</span></code> or <code class="docutils literal notranslate"><span class="pre">cats.Pet</span></code>
argument:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">m</span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;pet_name&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">[](</span><span class="k">const</span><span class="w"> </span><span class="n">pets</span><span class="o">::</span><span class="n">Pet</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pet</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">pet</span><span class="p">.</span><span class="n">name</span><span class="p">();</span><span class="w"> </span><span class="p">});</span>
</pre></div>
</div>
<p>For example, suppose the above function is added to each of <code class="docutils literal notranslate"><span class="pre">cats.cpp</span></code>,
<code class="docutils literal notranslate"><span class="pre">dogs.cpp</span></code> and <code class="docutils literal notranslate"><span class="pre">frogs.cpp</span></code> (where <code class="docutils literal notranslate"><span class="pre">frogs.cpp</span></code> is some other module that
does <em>not</em> bind <code class="docutils literal notranslate"><span class="pre">Pets</span></code> at all).</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">cats</span><span class="o">,</span><span class="w"> </span><span class="nn">dogs</span><span class="o">,</span><span class="w"> </span><span class="nn">frogs</span>  <span class="c1"># No error because of the added py::module_local()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mycat</span><span class="p">,</span> <span class="n">mydog</span> <span class="o">=</span> <span class="n">cats</span><span class="o">.</span><span class="n">Cat</span><span class="p">(</span><span class="s2">&quot;Fluffy&quot;</span><span class="p">),</span> <span class="n">dogs</span><span class="o">.</span><span class="n">Dog</span><span class="p">(</span><span class="s2">&quot;Rover&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">cats</span><span class="o">.</span><span class="n">pet_name</span><span class="p">(</span><span class="n">mycat</span><span class="p">),</span> <span class="n">dogs</span><span class="o">.</span><span class="n">pet_name</span><span class="p">(</span><span class="n">mydog</span><span class="p">))</span>
<span class="go">(&#39;Fluffy&#39;, &#39;Rover&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">cats</span><span class="o">.</span><span class="n">pet_name</span><span class="p">(</span><span class="n">mydog</span><span class="p">),</span> <span class="n">dogs</span><span class="o">.</span><span class="n">pet_name</span><span class="p">(</span><span class="n">mycat</span><span class="p">),</span> <span class="n">frogs</span><span class="o">.</span><span class="n">pet_name</span><span class="p">(</span><span class="n">mycat</span><span class="p">))</span>
<span class="go">(&#39;Rover&#39;, &#39;Fluffy&#39;, &#39;Fluffy&#39;)</span>
</pre></div>
</div>
<p>It is possible to use <code class="docutils literal notranslate"><span class="pre">py::module_local()</span></code> registrations in one module even
if another module registers the same type globally: within the module with the
module-local definition, all C++ instances will be cast to the associated bound
Python type.  In other modules any such values are converted to the global
Python type created elsewhere.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>STL bindings (as provided via the optional <code class="file docutils literal notranslate"><span class="pre">pybind11/stl_bind.h</span></code>
header) apply <code class="docutils literal notranslate"><span class="pre">py::module_local</span></code> by default when the bound type might
conflict with other modules; see <a class="reference internal" href="cast/stl.html#stl-bind"><span class="std std-ref">Binding STL containers</span></a> for details.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The localization of the bound types is actually tied to the shared object
or binary generated by the compiler/linker.  For typical modules created
with <code class="docutils literal notranslate"><span class="pre">PYBIND11_MODULE()</span></code>, this distinction is not significant.  It is
possible, however, when <a class="reference internal" href="embedding.html#embedding"><span class="std std-ref">Embedding the interpreter</span></a> to embed multiple modules in the
same binary (see <a class="reference internal" href="embedding.html#embedding-modules"><span class="std std-ref">Adding embedded modules</span></a>).  In such a case, the
localization will apply across all embedded modules within the same binary.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>The file <code class="file docutils literal notranslate"><span class="pre">tests/test_local_bindings.cpp</span></code> contains additional examples
that demonstrate how <code class="docutils literal notranslate"><span class="pre">py::module_local()</span></code> works.</p>
</div>
</section>
<section id="binding-protected-member-functions">
<h2>Binding protected member functions<a class="headerlink" href="#binding-protected-member-functions" title="Link to this heading"></a></h2>
<p>It’s normally not possible to expose <code class="docutils literal notranslate"><span class="pre">protected</span></code> member functions to Python:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">A</span><span class="w"> </span><span class="p">{</span>
<span class="k">protected</span><span class="o">:</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">foo</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>

<span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;A&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">A</span><span class="o">::</span><span class="n">foo</span><span class="p">);</span><span class="w"> </span><span class="c1">// error: &#39;foo&#39; is a protected member of &#39;A&#39;</span>
</pre></div>
</div>
<p>On one hand, this is good because non-<code class="docutils literal notranslate"><span class="pre">public</span></code> members aren’t meant to be
accessed from the outside. But we may want to make use of <code class="docutils literal notranslate"><span class="pre">protected</span></code>
functions in derived Python classes.</p>
<p>The following pattern makes this possible:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">A</span><span class="w"> </span><span class="p">{</span>
<span class="k">protected</span><span class="o">:</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">foo</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Publicist</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// helper type for exposing protected functions</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">A</span><span class="o">::</span><span class="n">foo</span><span class="p">;</span><span class="w"> </span><span class="c1">// inherited with different access modifier</span>
<span class="p">};</span>

<span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;A&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">// bind the primary class</span>
<span class="w">    </span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Publicist</span><span class="o">::</span><span class="n">foo</span><span class="p">);</span><span class="w"> </span><span class="c1">// expose protected methods via the publicist</span>
</pre></div>
</div>
<p>This works because <code class="docutils literal notranslate"><span class="pre">&amp;Publicist::foo</span></code> is exactly the same function as
<code class="docutils literal notranslate"><span class="pre">&amp;A::foo</span></code> (same signature and address), just with a different access
modifier. The only purpose of the <code class="docutils literal notranslate"><span class="pre">Publicist</span></code> helper class is to make
the function name <code class="docutils literal notranslate"><span class="pre">public</span></code>.</p>
<p>If the intent is to expose <code class="docutils literal notranslate"><span class="pre">protected</span></code> <code class="docutils literal notranslate"><span class="pre">virtual</span></code> functions which can be
overridden in Python, the publicist pattern can be combined with the previously
described trampoline:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">A</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">A</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span>

<span class="k">protected</span><span class="o">:</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">foo</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Trampoline</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">foo</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">PYBIND11_OVERRIDE</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="p">);</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Publicist</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="k">using</span><span class="w"> </span><span class="n">A</span><span class="o">::</span><span class="n">foo</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">Trampoline</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;A&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">// &lt;-- `Trampoline` here</span>
<span class="w">    </span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Publicist</span><span class="o">::</span><span class="n">foo</span><span class="p">);</span><span class="w"> </span><span class="c1">// &lt;-- `Publicist` here, not `Trampoline`!</span>
</pre></div>
</div>
</section>
<section id="binding-final-classes">
<h2>Binding final classes<a class="headerlink" href="#binding-final-classes" title="Link to this heading"></a></h2>
<p>Some classes may not be appropriate to inherit from. In C++11, classes can
use the <code class="docutils literal notranslate"><span class="pre">final</span></code> specifier to ensure that a class cannot be inherited from.
The <code class="docutils literal notranslate"><span class="pre">py::is_final</span></code> attribute can be used to ensure that Python classes
cannot inherit from a specified type. The underlying C++ type does not need
to be declared final.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">IsFinal</span><span class="w"> </span><span class="k">final</span><span class="w"> </span><span class="p">{};</span>

<span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">IsFinal</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;IsFinal&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">py</span><span class="o">::</span><span class="n">is_final</span><span class="p">());</span>
</pre></div>
</div>
<p>When you try to inherit from such a class in Python, you will now get this
error:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span><span class="w"> </span><span class="nc">PyFinalChild</span><span class="p">(</span><span class="n">IsFinal</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">...</span>
<span class="go">TypeError: type &#39;IsFinal&#39; is not an acceptable base type</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This attribute is currently ignored on PyPy</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 2.6.</span></p>
</div>
</section>
<section id="binding-classes-with-template-parameters">
<h2>Binding classes with template parameters<a class="headerlink" href="#binding-classes-with-template-parameters" title="Link to this heading"></a></h2>
<p>pybind11 can also wrap classes that have template parameters. Consider these classes:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">Cat</span><span class="w"> </span><span class="p">{};</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Dog</span><span class="w"> </span><span class="p">{};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">PetType</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Cage</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Cage</span><span class="p">(</span><span class="n">PetType</span><span class="o">&amp;</span><span class="w"> </span><span class="n">pet</span><span class="p">);</span>
<span class="w">    </span><span class="n">PetType</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">get</span><span class="p">();</span>
<span class="p">};</span>
</pre></div>
</div>
<p>C++ templates may only be instantiated at compile time, so pybind11 can only
wrap instantiated templated classes. You cannot wrap a non-instantiated template:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// BROKEN (this will not compile)</span>
<span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">Cage</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Cage&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;get&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Cage</span><span class="o">::</span><span class="n">get</span><span class="p">);</span>
</pre></div>
</div>
<p>You must explicitly specify each template/type combination that you want to
wrap separately.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// ok</span>
<span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">Cage</span><span class="o">&lt;</span><span class="n">Cat</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;CatCage&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;get&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Cage</span><span class="o">&lt;</span><span class="n">Cat</span><span class="o">&gt;::</span><span class="n">get</span><span class="p">);</span>

<span class="c1">// ok</span>
<span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">Cage</span><span class="o">&lt;</span><span class="n">Dog</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;DogCage&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;get&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">Cage</span><span class="o">&lt;</span><span class="n">Dog</span><span class="o">&gt;::</span><span class="n">get</span><span class="p">);</span>
</pre></div>
</div>
<p>If your class methods have template parameters you can wrap those as well,
but once again each instantiation must be explicitly specified:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">typename</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">MyClass</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">V</span><span class="o">&gt;</span>
<span class="w">    </span><span class="n">T</span><span class="w"> </span><span class="n">fn</span><span class="p">(</span><span class="n">V</span><span class="w"> </span><span class="n">v</span><span class="p">);</span>
<span class="p">};</span>

<span class="n">py</span><span class="o">::</span><span class="k">class</span><span class="o">&lt;</span><span class="n">MyClass</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;MyClassT&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;fn&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">MyClass</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">fn</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="custom-automatic-downcasters">
<h2>Custom automatic downcasters<a class="headerlink" href="#custom-automatic-downcasters" title="Link to this heading"></a></h2>
<p>As explained in <a class="reference internal" href="../classes.html#inheritance"><span class="std std-ref">Inheritance and automatic downcasting</span></a>, pybind11 comes with built-in
understanding of the dynamic type of polymorphic objects in C++; that
is, returning a Pet to Python produces a Python object that knows it’s
wrapping a Dog, if Pet has virtual methods and pybind11 knows about
Dog and this Pet is in fact a Dog. Sometimes, you might want to
provide this automatic downcasting behavior when creating bindings for
a class hierarchy that does not use standard C++ polymorphism, such as
LLVM <a class="footnote-reference brackets" href="#f4" id="id7" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a>. As long as there’s some way to determine at runtime
whether a downcast is safe, you can proceed by specializing the
<code class="docutils literal notranslate"><span class="pre">pybind11::polymorphic_type_hook</span></code> template:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">PetKind</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">Cat</span><span class="p">,</span><span class="w"> </span><span class="n">Dog</span><span class="p">,</span><span class="w"> </span><span class="n">Zebra</span><span class="w"> </span><span class="p">};</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Pet</span><span class="w"> </span><span class="p">{</span><span class="w">   </span><span class="c1">// Not polymorphic: has no virtual methods</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">PetKind</span><span class="w"> </span><span class="n">kind</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">age</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="k">protected</span><span class="o">:</span>
<span class="w">    </span><span class="n">Pet</span><span class="p">(</span><span class="n">PetKind</span><span class="w"> </span><span class="n">_kind</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">kind</span><span class="p">(</span><span class="n">_kind</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="p">};</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Dog</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Pet</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Dog</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Pet</span><span class="p">(</span><span class="n">PetKind</span><span class="o">::</span><span class="n">Dog</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">sound</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;woof!&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">bark</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">sound</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">PYBIND11_NAMESPACE</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">template</span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">polymorphic_type_hook</span><span class="o">&lt;</span><span class="n">Pet</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">get</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Pet</span><span class="w"> </span><span class="o">*</span><span class="n">src</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">type_info</span><span class="o">*&amp;</span><span class="w"> </span><span class="n">type</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// note that src may be nullptr</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">src</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">src</span><span class="o">-&gt;</span><span class="n">kind</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">PetKind</span><span class="o">::</span><span class="n">Dog</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">typeid</span><span class="p">(</span><span class="n">Dog</span><span class="p">);</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">Dog</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">src</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">src</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">};</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// namespace PYBIND11_NAMESPACE</span>
</pre></div>
</div>
<p>When pybind11 wants to convert a C++ pointer of type <code class="docutils literal notranslate"><span class="pre">Base*</span></code> to a
Python object, it calls <code class="docutils literal notranslate"><span class="pre">polymorphic_type_hook&lt;Base&gt;::get()</span></code> to
determine if a downcast is possible. The <code class="docutils literal notranslate"><span class="pre">get()</span></code> function should use
whatever runtime information is available to determine if its <code class="docutils literal notranslate"><span class="pre">src</span></code>
parameter is in fact an instance of some class <code class="docutils literal notranslate"><span class="pre">Derived</span></code> that
inherits from <code class="docutils literal notranslate"><span class="pre">Base</span></code>. If it finds such a <code class="docutils literal notranslate"><span class="pre">Derived</span></code>, it sets <code class="docutils literal notranslate"><span class="pre">type</span>
<span class="pre">=</span> <span class="pre">&amp;typeid(Derived)</span></code> and returns a pointer to the <code class="docutils literal notranslate"><span class="pre">Derived</span></code> object
that contains <code class="docutils literal notranslate"><span class="pre">src</span></code>. Otherwise, it just returns <code class="docutils literal notranslate"><span class="pre">src</span></code>, leaving
<code class="docutils literal notranslate"><span class="pre">type</span></code> at its default value of nullptr. If you set <code class="docutils literal notranslate"><span class="pre">type</span></code> to a
type that pybind11 doesn’t know about, no downcasting will occur, and
the original <code class="docutils literal notranslate"><span class="pre">src</span></code> pointer will be used with its static type
<code class="docutils literal notranslate"><span class="pre">Base*</span></code>.</p>
<p>It is critical that the returned pointer and <code class="docutils literal notranslate"><span class="pre">type</span></code> argument of
<code class="docutils literal notranslate"><span class="pre">get()</span></code> agree with each other: if <code class="docutils literal notranslate"><span class="pre">type</span></code> is set to something
non-null, the returned pointer must point to the start of an object
whose type is <code class="docutils literal notranslate"><span class="pre">type</span></code>. If the hierarchy being exposed uses only
single inheritance, a simple <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">src;</span></code> will achieve this just
fine, but in the general case, you must cast <code class="docutils literal notranslate"><span class="pre">src</span></code> to the
appropriate derived-class pointer (e.g. using
<code class="docutils literal notranslate"><span class="pre">static_cast&lt;Derived&gt;(src)</span></code>) before allowing it to be returned as a
<code class="docutils literal notranslate"><span class="pre">void*</span></code>.</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="f4" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id7">3</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://llvm.org/docs/HowToSetUpLLVMStyleRTTI.html">https://llvm.org/docs/HowToSetUpLLVMStyleRTTI.html</a></p>
</aside>
</aside>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>pybind11’s standard support for downcasting objects whose types
have virtual methods is implemented using
<code class="docutils literal notranslate"><span class="pre">polymorphic_type_hook</span></code> too, using the standard C++ ability to
determine the most-derived type of a polymorphic object using
<code class="docutils literal notranslate"><span class="pre">typeid()</span></code> and to cast a base pointer to that most-derived type
(even if you don’t know what it is) using <code class="docutils literal notranslate"><span class="pre">dynamic_cast&lt;void*&gt;</span></code>.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>The file <code class="file docutils literal notranslate"><span class="pre">tests/test_tagbased_polymorphic.cpp</span></code> contains a
more complete example, including a demonstration of how to provide
automatic downcasting for an entire class hierarchy without
writing one get() function for each class.</p>
</div>
</section>
<section id="accessing-the-type-object">
<h2>Accessing the type object<a class="headerlink" href="#accessing-the-type-object" title="Link to this heading"></a></h2>
<p>You can get the type object from a C++ class that has already been registered using:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">py</span><span class="o">::</span><span class="n">type</span><span class="w"> </span><span class="n">T_py</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">py</span><span class="o">::</span><span class="n">type</span><span class="o">::</span><span class="n">of</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">();</span>
</pre></div>
</div>
<p>You can directly use <code class="docutils literal notranslate"><span class="pre">py::type::of(ob)</span></code> to get the type object from any python
object, just like <code class="docutils literal notranslate"><span class="pre">type(ob)</span></code> in Python.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Other types, like <code class="docutils literal notranslate"><span class="pre">py::type::of&lt;int&gt;()</span></code>, do not work, see <a class="reference internal" href="cast/index.html#type-conversions"><span class="std std-ref">Type conversions</span></a>.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 2.6.</span></p>
</div>
</section>
<section id="custom-type-setup">
<h2>Custom type setup<a class="headerlink" href="#custom-type-setup" title="Link to this heading"></a></h2>
<p>For advanced use cases, such as enabling garbage collection support, you may
wish to directly manipulate the <code class="docutils literal notranslate"><span class="pre">PyHeapTypeObject</span></code> corresponding to a
<code class="docutils literal notranslate"><span class="pre">py::class_</span></code> definition.</p>
<p>You can do that using <code class="docutils literal notranslate"><span class="pre">py::custom_type_setup</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">OwnsPythonObjects</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">py</span><span class="o">::</span><span class="n">object</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">py</span><span class="o">::</span><span class="n">none</span><span class="p">();</span>
<span class="p">};</span>
<span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">OwnsPythonObjects</span><span class="o">&gt;</span><span class="w"> </span><span class="n">cls</span><span class="p">(</span>
<span class="w">    </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;OwnsPythonObjects&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">py</span><span class="o">::</span><span class="n">custom_type_setup</span><span class="p">([](</span><span class="n">PyHeapTypeObject</span><span class="w"> </span><span class="o">*</span><span class="n">heap_type</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">heap_type</span><span class="o">-&gt;</span><span class="n">ht_type</span><span class="p">;</span>
<span class="w">        </span><span class="n">type</span><span class="o">-&gt;</span><span class="n">tp_flags</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">Py_TPFLAGS_HAVE_GC</span><span class="p">;</span>
<span class="w">        </span><span class="n">type</span><span class="o">-&gt;</span><span class="n">tp_traverse</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self_base</span><span class="p">,</span><span class="w"> </span><span class="n">visitproc</span><span class="w"> </span><span class="n">visit</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">arg</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="n">self</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">py</span><span class="o">::</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">OwnsPythonObjects</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">handle</span><span class="p">(</span><span class="n">self_base</span><span class="p">));</span>
<span class="w">            </span><span class="n">Py_VISIT</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">value</span><span class="p">.</span><span class="n">ptr</span><span class="p">());</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="p">};</span>
<span class="w">        </span><span class="n">type</span><span class="o">-&gt;</span><span class="n">tp_clear</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="n">PyObject</span><span class="w"> </span><span class="o">*</span><span class="n">self_base</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="n">self</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">py</span><span class="o">::</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">OwnsPythonObjects</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">handle</span><span class="p">(</span><span class="n">self_base</span><span class="p">));</span>
<span class="w">            </span><span class="n">self</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">py</span><span class="o">::</span><span class="n">none</span><span class="p">();</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="p">};</span>
<span class="w">    </span><span class="p">}));</span>
<span class="n">cls</span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">init</span><span class="o">&lt;&gt;</span><span class="p">());</span>
<span class="n">cls</span><span class="p">.</span><span class="n">def_readwrite</span><span class="p">(</span><span class="s">&quot;value&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">OwnsPythonObjects</span><span class="o">::</span><span class="n">value</span><span class="p">);</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 2.8.</span></p>
</div>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023-2025, EXP-code collaboration.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>